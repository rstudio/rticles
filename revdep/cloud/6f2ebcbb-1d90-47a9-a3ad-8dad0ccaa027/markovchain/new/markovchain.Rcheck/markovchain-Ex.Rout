
R version 4.1.1 (2021-08-10) -- "Kick Things"
Copyright (C) 2021 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "markovchain"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> library('markovchain')
Package:  markovchain
Version:  0.9.0
Date:     2022-07-01
BugReport: https://github.com/spedygiorgio/markovchain/issues

> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("ExpectedTime")
> ### * ExpectedTime
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ExpectedTime
> ### Title: Returns expected hitting time from state i to state j
> ### Aliases: ExpectedTime
> 
> ### ** Examples
> 
> states <- c("a","b","c","d")
> byRow <- TRUE
> gen <- matrix(data = c(-1, 1/2, 1/2, 0, 1/4, -1/2, 0, 1/4, 1/6, 0, -1/3, 1/6, 0, 0, 0, 0),
+ nrow = 4,byrow = byRow, dimnames = list(states,states))
> ctmc <- new("ctmc",states = states, byrow = byRow, generator = gen, name = "testctmc")
> ExpectedTime(ctmc,1,4,TRUE)
[1] 7
> 
> 
> 
> 
> cleanEx()
> nameEx("absorptionProbabilities")
> ### * absorptionProbabilities
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: absorptionProbabilities
> ### Title: Absorption probabilities
> ### Aliases: absorptionProbabilities
> 
> ### ** Examples
> 
> m <- matrix(c(1/2, 1/2, 0,
+               1/2, 1/2, 0,
+                 0, 1/2, 1/2), ncol = 3, byrow = TRUE)
> mc <- new("markovchain", states = letters[1:3], transitionMatrix = m)
> absorptionProbabilities(mc)
  a b
c 0 1
> 
> 
> 
> 
> cleanEx()
> nameEx("blanden")
> ### * blanden
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: blanden
> ### Title: Mobility between income quartiles
> ### Aliases: blanden
> ### Keywords: datasets
> 
> ### ** Examples
> 
> data(blanden)
> mobilityMc<-as(blanden, "markovchain")
> 
> 
> 
> cleanEx()
> nameEx("committorAB")
> ### * committorAB
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: committorAB
> ### Title: Calculates committor of a markovchain object with respect to set
> ###   A, B
> ### Aliases: committorAB
> 
> ### ** Examples
> 
> transMatr <- matrix(c(0,0,0,1,0.5,
+                       0.5,0,0,0,0,
+                       0.5,0,0,0,0,
+                       0,0.2,0.4,0,0,
+                       0,0.8,0.6,0,0.5),
+                       nrow = 5)
> object <- new("markovchain", states=c("a","b","c","d","e"),transitionMatrix=transMatr)
> committorAB(object,c(5),c(3))
        a         b         c         d         e 
0.4444444 0.8888889 0.0000000 0.4444444 1.0000000 
> 
> 
> 
> 
> cleanEx()
> nameEx("conditionalDistribution")
> ### * conditionalDistribution
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: conditionalDistribution
> ### Title: 'conditionalDistribution' of a Markov Chain
> ### Aliases: conditionalDistribution
> 
> ### ** Examples
> 
> # define a markov chain
> statesNames <- c("a", "b", "c")
> markovB <- new("markovchain", states = statesNames, transitionMatrix = 
+                matrix(c(0.2, 0.5, 0.3, 0, 1, 0, 0.1, 0.8, 0.1),nrow = 3, 
+                       byrow = TRUE, dimnames = list(statesNames, statesNames)))
>                       
> conditionalDistribution(markovB, "b")                       
a b c 
0 1 0 
> 
> 
> 
> 
> cleanEx()
> nameEx("craigsendi")
> ### * craigsendi
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: craigsendi
> ### Title: CD4 cells counts on HIV Infects between zero and six month
> ### Aliases: craigsendi
> ### Keywords: datasets
> 
> ### ** Examples
> 
> data(craigsendi)
> csMc<-as(craigsendi, "markovchain")
> steadyStates(csMc)
          0-49      50-74      75-UP
[1,] 0.8343668 0.07659214 0.08904103
> 
> 
> 
> cleanEx()
> nameEx("ctmc-class")
> ### * ctmc-class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ctmc-class
> ### Title: Continuous time Markov Chains class
> ### Aliases: ctmc-class dim,ctmc-method initialize,ctmc_method
> ###   states,ctmc-method steadyStates,ctmc-method plot,ctmc,missing-method
> ### Keywords: classes
> 
> ### ** Examples
> 
> energyStates <- c("sigma", "sigma_star")
> byRow <- TRUE
> gen <- matrix(data = c(-3, 3,
+                        1, -1), nrow = 2,
+               byrow = byRow, dimnames = list(energyStates, energyStates))
> molecularCTMC <- new("ctmc", states = energyStates, 
+                      byrow = byRow, generator = gen, 
+                      name = "Molecular Transition Model")
>                      steadyStates(molecularCTMC)
     sigma sigma_star
[1,]  0.25       0.75
> ## Not run: plot(molecularCTMC)
> 
> 
> 
> 
> cleanEx()
> nameEx("ctmcFit")
> ### * ctmcFit
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ctmcFit
> ### Title: Function to fit a CTMC
> ### Aliases: ctmcFit
> 
> ### ** Examples
> 
> data <- list(c("a", "b", "c", "a", "b", "a", "c", "b", "c"), c(0, 0.8, 2.1, 2.4, 4, 5, 5.9, 8.2, 9))
> ctmcFit(data)
$estimate
An object of class "ctmc"
Slot "states":
[1] "a" "b" "c"

Slot "byrow":
[1] TRUE

Slot "generator":
           a          b          c
a -0.9090909  0.6060606  0.3030303
b  0.3225806 -0.9677419  0.6451613
c  0.3846154  0.3846154 -0.7692308

Slot "name":
[1] ""


$errors
$errors$dtmcConfidenceInterval
$errors$dtmcConfidenceInterval$confidenceLevel
[1] 0.95

$errors$dtmcConfidenceInterval$lowerEndpointMatrix
  a b c
a 0 0 0
b 0 0 0
c 0 0 0

$errors$dtmcConfidenceInterval$upperEndpointMatrix
          a b         c
a 0.0000000 1 0.9866548
b 0.9866548 0 1.0000000
c 1.0000000 1 0.0000000


$errors$lambdaConfidenceInterval
$errors$lambdaConfidenceInterval$lowerEndpointVector
[1] 0.04576665 0.04871934 0.00000000

$errors$lambdaConfidenceInterval$upperEndpointVector
[1]  0.04576665  0.04871934 -0.12545166



> 
> 
> 
> 
> cleanEx()
> nameEx("expectedRewards")
> ### * expectedRewards
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: expectedRewards
> ### Title: Expected Rewards for a markovchain
> ### Aliases: expectedRewards
> 
> ### ** Examples
> 
> transMatr<-matrix(c(0.99,0.01,0.01,0.99),nrow=2,byrow=TRUE)
> simpleMc<-new("markovchain", states=c("a","b"),
+              transitionMatrix=transMatr)
> expectedRewards(simpleMc,1,c(0,1))
[1] 0.01 1.99
> 
> 
> 
> cleanEx()
> nameEx("firstPassage")
> ### * firstPassage
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: firstPassage
> ### Title: First passage across states
> ### Aliases: firstPassage
> 
> ### ** Examples
> 
> simpleMc <- new("markovchain", states = c("a", "b"),
+                  transitionMatrix = matrix(c(0.4, 0.6, .3, .7), 
+                                     nrow = 2, byrow = TRUE))
> firstPassage(simpleMc, "b", 20)
              a            b
1  0.3000000000 7.000000e-01
2  0.2100000000 1.800000e-01
3  0.1470000000 7.200000e-02
4  0.1029000000 2.880000e-02
5  0.0720300000 1.152000e-02
6  0.0504210000 4.608000e-03
7  0.0352947000 1.843200e-03
8  0.0247062900 7.372800e-04
9  0.0172944030 2.949120e-04
10 0.0121060821 1.179648e-04
11 0.0084742575 4.718592e-05
12 0.0059319802 1.887437e-05
13 0.0041523862 7.549747e-06
14 0.0029066703 3.019899e-06
15 0.0020346692 1.207960e-06
16 0.0014242685 4.831838e-07
17 0.0009969879 1.932735e-07
18 0.0006978915 7.730941e-08
19 0.0004885241 3.092376e-08
20 0.0003419669 1.236951e-08
> 
> 
> 
> 
> cleanEx()
> nameEx("firstPassageMultiple")
> ### * firstPassageMultiple
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: firstPassageMultiple
> ### Title: function to calculate first passage probabilities
> ### Aliases: firstPassageMultiple
> 
> ### ** Examples
> 
> statesNames <- c("a", "b", "c")
> markovB <- new("markovchain", states = statesNames, transitionMatrix =
+ matrix(c(0.2, 0.5, 0.3,
+          0, 1, 0,
+          0.1, 0.8, 0.1), nrow = 3, byrow = TRUE,
+        dimnames = list(statesNames, statesNames)
+ ))
> firstPassageMultiple(markovB,"a",c("b","c"),4)  
     set
1 0.8000
2 0.4000
3 0.1190
4 0.0379
> 
> 
> 
> 
> cleanEx()
> nameEx("fitHighOrderMultivarMC")
> ### * fitHighOrderMultivarMC
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: fitHighOrderMultivarMC
> ### Title: Function to fit Higher Order Multivariate Markov chain
> ### Aliases: fitHighOrderMultivarMC
> 
> ### ** Examples
> 
> data <- matrix(c('2', '1', '3', '3', '4', '3', '2', '1', '3', '3', '2', '1', 
+                c('2', '4', '4', '4', '4', '2', '3', '3', '1', '4', '3', '3')), 
+                ncol = 2, byrow = FALSE)
>                
> fitHighOrderMultivarMC(data, order = 2, Norm = 2)                
This function is experimental
Order of multivariate markov chain = 2 
states = 1 2 3 4 

List of Lambda's and the corresponding transition matrix (by cols) :
Lambda1(1,1) : 0.2496703
P1(1,1) : 
  1 2   3 4
1 0 1 0.0 0
2 0 0 0.4 0
3 1 0 0.4 1
4 0 0 0.2 0

Lambda2(1,1) : 6.559911e-05
P2(1,1) : 
  1 2   3 4
1 0 0 0.4 0
2 0 0 0.2 1
3 1 1 0.2 0
4 0 0 0.2 0

Lambda1(1,2) : 0.7501985
P1(1,2) : 
  1   2         3   4
1 0 0.5 0.6666667 0.0
2 0 0.5 0.0000000 0.2
3 1 0.0 0.3333333 0.6
4 0 0.0 0.0000000 0.2

Lambda2(1,2) : 6.559955e-05
P2(1,2) : 
  1   2 3   4
1 0 0.5 0 0.2
2 1 0.0 0 0.2
3 0 0.5 1 0.4
4 0 0.0 0 0.2

Lambda1(2,1) : 0.2692313
P1(2,1) : 
    1         2   3 4
1 0.5 0.0000000 0.0 0
2 0.0 0.0000000 0.0 1
3 0.0 0.6666667 0.4 0
4 0.5 0.3333333 0.6 0

Lambda2(2,1) : 0.2692313
P2(2,1) : 
  1   2   3 4
1 0 0.5 0.0 0
2 0 0.0 0.2 0
3 0 0.0 0.6 1
4 1 0.5 0.2 0

Lambda1(2,2) : 0.4615374
P1(2,2) : 
  1   2         3   4
1 0 0.0 0.3333333 0.0
2 0 0.0 0.0000000 0.2
3 0 0.5 0.6666667 0.2
4 1 0.5 0.0000000 0.6

Lambda2(2,2) : 8.014089e-09
P2(2,2) : 
  1   2   3   4
1 0 0.0 0.5 0.0
2 0 0.0 0.0 0.2
3 1 0.5 0.0 0.4
4 0 0.5 0.5 0.4

> 
> 
> 
> 
> cleanEx()
> nameEx("fitHigherOrder")
> ### * fitHigherOrder
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: fitHigherOrder
> ### Title: Functions to fit a higher order Markov chain
> ### Aliases: fitHigherOrder seq2freqProb seq2matHigh
> 
> ### ** Examples
> 
> sequence<-c("a", "a", "b", "b", "a", "c", "b", "a", "b", "c", "a", "b",
+             "c", "a", "b", "c", "a", "b", "a", "b")
> fitHigherOrder(sequence)
$lambda
[1] 1.000000e+00 1.626303e-08

$Q
$Q[[1]]
      a         b    c
a 0.125 0.4285714 0.75
b 0.750 0.1428571 0.25
c 0.125 0.4285714 0.00

$Q[[2]]
          a         b    c
a 0.1428571 0.5714286 0.25
b 0.4285714 0.2857143 0.75
c 0.4285714 0.1428571 0.00


$X
  a   b   c 
0.4 0.4 0.2 

> 
> 
> 
> 
> cleanEx()
> nameEx("freq2Generator")
> ### * freq2Generator
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: freq2Generator
> ### Title: Returns a generator matrix corresponding to frequency matrix
> ### Aliases: freq2Generator
> 
> ### ** Examples
> 
> sample <- matrix(c(150,2,1,1,1,200,2,1,2,1,175,1,1,1,1,150),nrow = 4,byrow = TRUE)
> sample_rel = rbind((sample/rowSums(sample))[1:dim(sample)[1]-1,],c(rep(0,dim(sample)[1]-1),1)) 
> freq2Generator(sample_rel,1)
             [,1]        [,2]         [,3] [,4]
[1,] -0.024212164  0.01544797  0.008764198    0
[2,]  0.006594821 -0.01822834  0.011633520    0
[3,]  0.013302567  0.00749703 -0.020799597    0
[4,]  0.000000000  0.00000000  0.000000000    0
> 
> data(tm_abs)
> tm_rel=rbind((tm_abs/rowSums(tm_abs))[1:7,],c(rep(0,7),1))
> ## Derive quasi optimization generator matrix estimate
> freq2Generator(tm_rel,1)
             AAA           AA            A          BBB           BB
AAA -0.109688198  0.104742772  0.004945426  0.000000000  0.000000000
AA   0.006375885 -0.095416840  0.088027218  0.001013738  0.000000000
A    0.000000000  0.037605369 -0.139127796  0.092863518  0.002082790
BBB  0.000000000  0.003101629  0.043766820 -0.100963213  0.044471253
BB   0.000000000  0.004024583  0.000000000  0.043976931 -0.142486437
B    0.000000000  0.005844572  0.003289642  0.005803757  0.058923108
C    0.000000000  0.000000000  0.000000000  0.000000000  0.006651241
     0.000000000  0.000000000  0.000000000  0.000000000  0.000000000
                B            C           D
AAA  0.000000e+00  0.000000000 0.000000000
AA   0.000000e+00  0.000000000 0.000000000
A    1.064427e-05  0.004562575 0.002002900
BBB  4.257673e-03  0.001871779 0.003494059
BB   8.610403e-02  0.008380896 0.000000000
B   -1.932222e-01  0.064440303 0.054920850
C    1.547477e-01 -0.362361432 0.200962499
     0.000000e+00  0.000000000 0.000000000
> 
> 
> 
> 
> cleanEx()
> nameEx("generatorToTransitionMatrix")
> ### * generatorToTransitionMatrix
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: generatorToTransitionMatrix
> ### Title: Function to obtain the transition matrix from the generator
> ### Aliases: generatorToTransitionMatrix
> 
> ### ** Examples
> 
> energyStates <- c("sigma", "sigma_star")
> byRow <- TRUE
> gen <- matrix(data = c(-3, 3, 1, -1), nrow = 2,
+               byrow = byRow, dimnames = list(energyStates, energyStates))
> generatorToTransitionMatrix(gen)
           sigma sigma_star
sigma          0          1
sigma_star     1          0
> 
> 
> 
> 
> cleanEx()
> nameEx("getName")
> ### * getName
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: name
> ### Title: Method to retrieve name of markovchain object
> ### Aliases: name name,markovchain-method
> 
> ### ** Examples
> 
> statesNames <- c("a", "b", "c")
> markovB <- new("markovchain", states = statesNames, transitionMatrix =
+                 matrix(c(0.2, 0.5, 0.3, 0, 1, 0, 0.1, 0.8, 0.1), nrow = 3,
+                 byrow = TRUE, dimnames=list(statesNames,statesNames)),
+                 name = "A markovchain Object" 
+ )
> name(markovB)
[1] "A markovchain Object"
> 
> 
> 
> 
> cleanEx()
> nameEx("hittingProbabilities")
> ### * hittingProbabilities
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: hittingProbabilities
> ### Title: Hitting probabilities for markovchain
> ### Aliases: hittingProbabilities
> 
> ### ** Examples
> 
> M <- markovchain:::zeros(5)
> M[1,1] <- M[5,5] <- 1
> M[2,1] <- M[2,3] <- 1/2
> M[3,2] <- M[3,4] <- 1/2
> M[4,2] <- M[4,5] <- 1/2
> 
> mc <- new("markovchain", transitionMatrix = M)
> hittingProbabilities(mc)
    1     2     3         4   5
1 1.0 0.000 0.000 0.0000000 0.0
2 0.8 0.375 0.500 0.3333333 0.2
3 0.6 0.750 0.375 0.6666667 0.4
4 0.4 0.500 0.250 0.1666667 0.6
5 0.0 0.000 0.000 0.0000000 1.0
> 
> 
> 
> 
> cleanEx()
> nameEx("holson")
> ### * holson
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: holson
> ### Title: Holson data set
> ### Aliases: holson
> ### Keywords: datasets
> 
> ### ** Examples
> 
> data(holson)
> head(holson)
  id time1 time2 time3 time4 time5 time6 time7 time8 time9 time10 time11
1  1     1     1     1     1     1     1     1     1     1      1      1
2  2     1     1     1     1     1     1     1     1     1      1      1
3  3     1     1     1     1     1     1     1     1     1      1      1
4  4     1     1     1     1     2     1     1     1     1      1      1
5  5     1     1     1     1     1     1     1     1     1      1      1
6  6     1     1     1     1     1     1     1     1     1      1      1
> 
> 
> 
> cleanEx()
> nameEx("hommc-class")
> ### * hommc-class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: hommc-class
> ### Title: An S4 class for representing High Order Multivariate Markovchain
> ###   (HOMMC)
> ### Aliases: hommc-class hommc
> 
> ### ** Examples
> 
> statesName <- c("a", "b")
> 
> P <- array(0, dim = c(2, 2, 4), dimnames = list(statesName, statesName))
> P[,,1] <- matrix(c(0, 1, 1/3, 2/3), byrow = FALSE, nrow = 2)
> P[,,2] <- matrix(c(1/4, 3/4, 0, 1), byrow = FALSE, nrow = 2)
> P[,,3] <- matrix(c(1, 0, 1/3, 2/3), byrow = FALSE, nrow = 2)
> P[,,4] <- matrix(c(3/4, 1/4, 0, 1), byrow = FALSE, nrow = 2)
> 
> Lambda <- c(0.8, 0.2, 0.3, 0.7)
> 
> ob <- new("hommc", order = 1, states = statesName, P = P, 
+           Lambda = Lambda, byrow = FALSE, name = "FOMMC")
>           
> 
> 
> 
> cleanEx()
> nameEx("impreciseProbabilityatT")
> ### * impreciseProbabilityatT
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: impreciseProbabilityatT
> ### Title: Calculating full conditional probability using lower rate
> ###   transition matrix
> ### Aliases: impreciseProbabilityatT
> 
> ### ** Examples
> 
> states <- c("n","y")
> Q <- matrix(c(-1,1,1,-1),nrow = 2,byrow = TRUE,dimnames = list(states,states))
> range <- matrix(c(1/52,3/52,1/2,2),nrow = 2,byrow = 2)
> name <- "testictmc"
> ictmc <- new("ictmc",states = states,Q = Q,range = range,name = name)
> impreciseProbabilityatT(ictmc,2,0,1,10^-3,TRUE)
[1] 0.008259774 0.140983476
> 
> 
> 
> cleanEx()
> nameEx("inferHyperparam")
> ### * inferHyperparam
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: inferHyperparam
> ### Title: Function to infer the hyperparameters for Bayesian inference
> ###   from an a priori matrix or a data set
> ### Aliases: inferHyperparam
> 
> ### ** Examples
> 
> data(rain, package = "markovchain")
> inferHyperparam(data = rain$rain)
$dataInference
      0 1-5  6+
0   363 127  61
1-5 137  91  69
6+   51  80 125

>  
> weatherStates <- c("sunny", "cloudy", "rain")
> weatherMatrix <- matrix(data = c(0.7, 0.2, 0.1, 
+                                  0.3, 0.4, 0.3, 
+                                  0.2, 0.4, 0.4), 
+                         byrow = TRUE, nrow = 3, 
+                         dimnames = list(weatherStates, weatherStates))
> inferHyperparam(transMatr = weatherMatrix, scale = c(10, 10, 10))
$scaledInference
       cloudy rain sunny
cloudy      4    3     3
rain        4    4     2
sunny       2    1     7

>  
> 
> 
> 
> cleanEx()
> nameEx("is.CTMCirreducible")
> ### * is.CTMCirreducible
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: is.CTMCirreducible
> ### Title: Check if CTMC is irreducible
> ### Aliases: is.CTMCirreducible
> 
> ### ** Examples
> 
> energyStates <- c("sigma", "sigma_star")
> byRow <- TRUE
> gen <- matrix(data = c(-3, 3,
+                        1, -1), nrow = 2,
+               byrow = byRow, dimnames = list(energyStates, energyStates))
> molecularCTMC <- new("ctmc", states = energyStates, 
+                      byrow = byRow, generator = gen, 
+                      name = "Molecular Transition Model")
> is.CTMCirreducible(molecularCTMC)
[1] TRUE
> 
> 
> 
> 
> cleanEx()
> nameEx("is.TimeReversible")
> ### * is.TimeReversible
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: is.TimeReversible
> ### Title: checks if ctmc object is time reversible
> ### Aliases: is.TimeReversible
> 
> ### ** Examples
> 
> energyStates <- c("sigma", "sigma_star")
> byRow <- TRUE
> gen <- matrix(data = c(-3, 3,
+                        1, -1), nrow = 2,
+               byrow = byRow, dimnames = list(energyStates, energyStates))
> molecularCTMC <- new("ctmc", states = energyStates, 
+                      byrow = byRow, generator = gen, 
+                      name = "Molecular Transition Model")
> is.TimeReversible(molecularCTMC)
[1] TRUE
> 
> 
> 
> 
> cleanEx()
> nameEx("is.accessible")
> ### * is.accessible
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: is.accessible
> ### Title: Verify if a state j is reachable from state i.
> ### Aliases: is.accessible
> 
> ### ** Examples
> 
> statesNames <- c("a", "b", "c")
> markovB <- new("markovchain", states = statesNames, 
+                transitionMatrix = matrix(c(0.2, 0.5, 0.3,
+                                              0,   1,   0,
+                                            0.1, 0.8, 0.1), nrow = 3, byrow = TRUE, 
+                                          dimnames = list(statesNames, statesNames)
+                                         )
+                )
> is.accessible(markovB, "a", "c")
[1] TRUE
> 
> 
> 
> 
> cleanEx()
> nameEx("is.irreducible")
> ### * is.irreducible
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: is.irreducible
> ### Title: Function to check if a Markov chain is irreducible (i.e.
> ###   ergodic)
> ### Aliases: is.irreducible
> 
> ### ** Examples
> 
> statesNames <- c("a", "b")
> mcA <- new("markovchain", transitionMatrix = matrix(c(0.7,0.3,0.1,0.9),
+                                              byrow = TRUE, nrow = 2, 
+                                              dimnames = list(statesNames, statesNames)
+            ))
> is.irreducible(mcA)
[1] TRUE
> 
> 
> 
> 
> cleanEx()
> nameEx("is.regular")
> ### * is.regular
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: is.regular
> ### Title: Check if a DTMC is regular
> ### Aliases: is.regular
> 
> ### ** Examples
> 
> P <- matrix(c(0.5,  0.25, 0.25,
+               0.5,     0, 0.5,
+               0.25, 0.25, 0.5), nrow = 3)
> colnames(P) <- rownames(P) <- c("R","N","S")
> ciao <- as(P, "markovchain")
> is.regular(ciao)
[1] TRUE
> 
> 
> 
> 
> cleanEx()
> nameEx("markovchain-class")
> ### * markovchain-class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: markovchain-class
> ### Title: Markov Chain class
> ### Aliases: markovchain-class *,markovchain,markovchain-method
> ###   *,markovchain,matrix-method *,markovchain,numeric-method
> ###   *,matrix,markovchain-method *,numeric,markovchain-method
> ###   ==,markovchain,markovchain-method !=,markovchain,markovchain-method
> ###   absorbingStates,markovchain-method transientStates,markovchain-method
> ###   recurrentStates,markovchain-method
> ###   transientClasses,markovchain-method
> ###   recurrentClasses,markovchain-method
> ###   communicatingClasses,markovchain-method
> ###   steadyStates,markovchain-method meanNumVisits,markovchain-method
> ###   is.regular,markovchain-method is.irreducible,markovchain-method
> ###   is.accessible,markovchain,character,character-method
> ###   is.accessible,markovchain,missing,missing-method
> ###   absorptionProbabilities,markovchain-method
> ###   meanFirstPassageTime,markovchain,character-method
> ###   meanFirstPassageTime,markovchain,missing-method
> ###   meanAbsorptionTime,markovchain-method
> ###   meanRecurrenceTime,markovchain-method
> ###   conditionalDistribution,markovchain-method
> ###   hittingProbabilities,markovchain-method
> ###   canonicForm,markovchain-method coerce,data.frame,markovchain-method
> ###   coerce,markovchain,data.frame-method coerce,table,markovchain-method
> ###   coerce,markovchain,igraph-method coerce,markovchain,matrix-method
> ###   coerce,markovchain,sparseMatrix-method
> ###   coerce,sparseMatrix,markovchain-method
> ###   coerce,matrix,markovchain-method coerce,msm,markovchain-method
> ###   coerce,msm.est,markovchain-method coerce,etm,markovchain-method
> ###   dim,markovchain-method initialize,markovchain-method
> ###   names<-,markovchain-method plot,markovchain,missing-method
> ###   predict,markovchain-method print,markovchain-method
> ###   show,markovchain-method summary,markovchain-method
> ###   sort,markovchain-method t,markovchain-method
> ###   [,markovchain,ANY,ANY,ANY-method ^,markovchain,numeric-method
> ### Keywords: classes
> 
> ### ** Examples
> 
> #show markovchain definition
> showClass("markovchain")
Class "markovchain" [package "markovchain"]

Slots:
                                                                          
Name:            states            byrow transitionMatrix             name
Class:        character          logical           matrix        character
> #create a simple Markov chain
> transMatr<-matrix(c(0.4,0.6,.3,.7),nrow=2,byrow=TRUE)
> simpleMc<-new("markovchain", states=c("a","b"),
+               transitionMatrix=transMatr, 
+               name="simpleMc")
> #power
> simpleMc^4
simpleMc^4 
 A  2 - dimensional discrete Markov Chain defined by the following states: 
 a, b 
 The transition matrix  (by rows)  is defined as follows: 
       a      b
a 0.3334 0.6666
b 0.3333 0.6667

> #some methods
> steadyStates(simpleMc)
             a         b
[1,] 0.3333333 0.6666667
> absorbingStates(simpleMc)
character(0)
> simpleMc[2,1]
[1] 0.3
> t(simpleMc)
Unnamed Markov chain 
 A  2 - dimensional discrete Markov Chain defined by the following states: 
 a, b 
 The transition matrix  (by cols)  is defined as follows: 
    a   b
a 0.4 0.3
b 0.6 0.7

> is.irreducible(simpleMc)
[1] TRUE
> #conditional distributions
> conditionalDistribution(simpleMc, "b")
  a   b 
0.3 0.7 
> #example for predict method
> sequence<-c("a", "b", "a", "a", "a", "a", "b", "a", "b", "a", "b", "a", "a", "b", "b", "b", "a")
> mcFit<-markovchainFit(data=sequence)
> predict(mcFit$estimate, newdata="b",n.ahead=3)
[1] "a" "b" "a"
> #direct conversion
> myMc<-as(transMatr, "markovchain")
> 
> #example of summary
> summary(simpleMc)
simpleMc  Markov chain that is composed by: 
Closed classes: 
a b 
Recurrent classes: 
{a,b}
Transient classes: 
NONE 
The Markov chain is irreducible 
The absorbing states are: NONE
> ## Not run: plot(simpleMc)
> 
> 
> 
> 
> cleanEx()
> nameEx("markovchain")
> ### * markovchain
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: markovchain-package
> ### Title: Easy Handling Discrete Time Markov Chains
> ### Aliases: markovchain-package
> ### Keywords: package
> 
> ### ** Examples
> 
> # create some markov chains
> statesNames=c("a","b")
> mcA<-new("markovchain", transitionMatrix=matrix(c(0.7,0.3,0.1,0.9),byrow=TRUE,
+          nrow=2, dimnames=list(statesNames,statesNames)))
>          
> statesNames=c("a","b","c")
> mcB<-new("markovchain", states=statesNames, transitionMatrix=
+          matrix(c(0.2,0.5,0.3,0,1,0,0.1,0.8,0.1), nrow=3, 
+          byrow=TRUE, dimnames=list(statesNames, statesNames)))
> 
> statesNames=c("a","b","c","d")
> matrice<-matrix(c(0.25,0.75,0,0,0.4,0.6,0,0,0,0,0.1,0.9,0,0,0.7,0.3), nrow=4, byrow=TRUE)
> mcC<-new("markovchain", states=statesNames, transitionMatrix=matrice)
> mcD<-new("markovchain", transitionMatrix=matrix(c(0,1,0,1), nrow=2,byrow=TRUE))
> 
> 
> #operations with S4 methods
> mcA^2
Unnamed Markov chain^2 
 A  2 - dimensional discrete Markov Chain defined by the following states: 
 a, b 
 The transition matrix  (by rows)  is defined as follows: 
     a    b
a 0.52 0.48
b 0.16 0.84

> steadyStates(mcB)
     a b c
[1,] 0 1 0
> absorbingStates(mcB)
[1] "b"
> markovchainSequence(n=20, markovchain=mcC, include=TRUE)
 [1] "a" "b" "b" "a" "b" "a" "a" "b" "a" "b" "b" "b" "a" "b" "a" "b" "a" "a" "b"
[20] "a" "a"
> 
> 
> 
> cleanEx()
> nameEx("markovchainFit")
> ### * markovchainFit
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: createSequenceMatrix
> ### Title: Function to fit a discrete Markov chain
> ### Aliases: createSequenceMatrix markovchainFit
> 
> ### ** Examples
> 
> sequence <- c("a", "b", "a", "a", "a", "a", "b", "a", "b", "a", "b", "a", "a", 
+               "b", "b", "b", "a")        
> sequenceMatr <- createSequenceMatrix(sequence, sanitize = FALSE)
> mcFitMLE <- markovchainFit(data = sequence)
> mcFitBSP <- markovchainFit(data = sequence, method = "bootstrap", nboot = 5, name = "Bootstrap Mc")
> 
> na.sequence <- c("a", NA, "a", "b")
> # There will be only a (a,b) transition        
> na.sequenceMatr <- createSequenceMatrix(na.sequence, sanitize = FALSE)
> mcFitMLE <- markovchainFit(data = na.sequence)
> 
> # data can be a list of character vectors
> sequences <- list(x = c("a", "b", "a"), y = c("b", "a", "b", "a", "c"))
> mcFitMap <- markovchainFit(sequences, method = "map")
> mcFitMle <- markovchainFit(sequences, method = "mle")
> 
> 
> 
> cleanEx()
> nameEx("markovchainList-class")
> ### * markovchainList-class
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: markovchainList-class
> ### Title: Non homogeneus discrete time Markov Chains class
> ### Aliases: markovchainList-class [[,markovchainList-method
> ###   dim,markovchainList-method predict,markovchainList-method
> ###   print,markovchainList-method show,markovchainList-method
> ### Keywords: classes
> 
> ### ** Examples
> 
> showClass("markovchainList")
Class "markovchainList" [package "markovchain"]

Slots:
                                
Name:  markovchains         name
Class:         list    character
> #define a markovchainList
> statesNames=c("a","b")
> 
> mcA<-new("markovchain",name="MCA", 
+          transitionMatrix=matrix(c(0.7,0.3,0.1,0.9),
+                           byrow=TRUE, nrow=2, 
+                           dimnames=list(statesNames,statesNames))
+         )
>                                                            
> mcB<-new("markovchain", states=c("a","b","c"), name="MCB",
+          transitionMatrix=matrix(c(0.2,0.5,0.3,0,1,0,0.1,0.8,0.1),
+          nrow=3, byrow=TRUE))
>  
> mcC<-new("markovchain", states=c("a","b","c","d"), name="MCC",
+          transitionMatrix=matrix(c(0.25,0.75,0,0,0.4,0.6,
+                                    0,0,0,0,0.1,0.9,0,0,0.7,0.3), 
+                                  nrow=4, byrow=TRUE)
+ )
> mcList<-new("markovchainList",markovchains=list(mcA, mcB, mcC), 
+            name="Non - homogeneous Markov Chain")
> 
> 
> 
> 
> cleanEx()
> nameEx("markovchainListFit")
> ### * markovchainListFit
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: markovchainListFit
> ### Title: markovchainListFit
> ### Aliases: markovchainListFit
> 
> ### ** Examples
> 
> 
> # using holson dataset
> data(holson)
> # fitting a single markovchain
> singleMc <- markovchainFit(data = holson[,2:12])
> # fitting a markovchainList
> mclistFit <- markovchainListFit(data = holson[, 2:12], name = "holsonMcList")
> 
> 
> 
> cleanEx()
> nameEx("markovchainSequence")
> ### * markovchainSequence
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: markovchainSequence
> ### Title: Function to generate a sequence of states from homogeneous
> ###   Markov chains.
> ### Aliases: markovchainSequence
> 
> ### ** Examples
> 
> # define the markovchain object
> statesNames <- c("a", "b", "c")
> mcB <- new("markovchain", states = statesNames, 
+    transitionMatrix = matrix(c(0.2, 0.5, 0.3, 0, 0.2, 0.8, 0.1, 0.8, 0.1), 
+    nrow = 3, byrow = TRUE, dimnames = list(statesNames, statesNames)))
> 
> # show the sequence
> outs <- markovchainSequence(n = 100, markovchain = mcB, t0 = "a")
> 
> 
> 
> 
> cleanEx()
> nameEx("meanAbsorptionTime")
> ### * meanAbsorptionTime
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: meanAbsorptionTime
> ### Title: Mean absorption time
> ### Aliases: meanAbsorptionTime
> 
> ### ** Examples
> 
> m <- matrix(c(1/2, 1/2, 0,
+               1/2, 1/2, 0,
+                 0, 1/2, 1/2), ncol = 3, byrow = TRUE)
> mc <- new("markovchain", states = letters[1:3], transitionMatrix = m)
> times <- meanAbsorptionTime(mc)
> 
> 
> 
> 
> cleanEx()
> nameEx("meanFirstPassageTime")
> ### * meanFirstPassageTime
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: meanFirstPassageTime
> ### Title: Mean First Passage Time for irreducible Markov chains
> ### Aliases: meanFirstPassageTime
> 
> ### ** Examples
> 
> m <- matrix(1 / 10 * c(6,3,1,
+                        2,3,5,
+                        4,1,5), ncol = 3, byrow = TRUE)
> mc <- new("markovchain", states = c("s","c","r"), transitionMatrix = m)
> meanFirstPassageTime(mc, "r")
       s        c 
4.545455 2.727273 
> 
> 
> # Grinstead and Snell's "Oz weather" worked out example
> mOz <- matrix(c(2,1,1,
+                 2,0,2,
+                 1,1,2)/4, ncol = 3, byrow = TRUE)
> 
> mcOz <- new("markovchain", states = c("s", "c", "r"), transitionMatrix = mOz)
> meanFirstPassageTime(mcOz)
         s c        r
s 0.000000 4 3.333333
c 2.666667 0 2.666667
r 3.333333 4 0.000000
> 
> 
> 
> 
> cleanEx()
> nameEx("meanNumVisits")
> ### * meanNumVisits
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: meanNumVisits
> ### Title: Mean num of visits for markovchain, starting at each state
> ### Aliases: meanNumVisits
> 
> ### ** Examples
> 
> M <- markovchain:::zeros(5)
> M[1,1] <- M[5,5] <- 1
> M[2,1] <- M[2,3] <- 1/2
> M[3,2] <- M[3,4] <- 1/2
> M[4,2] <- M[4,5] <- 1/2
> 
> mc <- new("markovchain", transitionMatrix = M)
> meanNumVisits(mc)
    1   2   3   4   5
1 Inf 0.0 0.0 0.0   0
2 Inf 0.6 0.8 0.4 Inf
3 Inf 1.2 0.6 0.8 Inf
4 Inf 0.8 0.4 0.2 Inf
5   0 0.0 0.0 0.0 Inf
> 
> 
> 
> 
> cleanEx()
> nameEx("meanRecurrenceTime")
> ### * meanRecurrenceTime
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: meanRecurrenceTime
> ### Title: Mean recurrence time
> ### Aliases: meanRecurrenceTime
> 
> ### ** Examples
> 
> m <- matrix(1 / 10 * c(6,3,1,
+                        2,3,5,
+                        4,1,5), ncol = 3, byrow = TRUE)
> mc <- new("markovchain", states = c("s","c","r"), transitionMatrix = m)
> meanRecurrenceTime(mc)
       s        c        r 
2.266667 4.250000 3.090909 
> 
> 
> 
> 
> cleanEx()
> nameEx("multinomialConfidenceIntervals")
> ### * multinomialConfidenceIntervals
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: multinomialConfidenceIntervals
> ### Title: A function to compute multinomial confidence intervals of DTMC
> ### Aliases: multinomialConfidenceIntervals
> 
> ### ** Examples
> 
> seq<-c("a", "b", "a", "a", "a", "a", "b", "a", "b", "a", "b", "a", "a", "b", "b", "b", "a")
> mcfit<-markovchainFit(data=seq,byrow=TRUE)
> seqmat<-createSequenceMatrix(seq)
> multinomialConfidenceIntervals(mcfit$estimate@transitionMatrix, seqmat, 0.95)
$confidenceLevel
[1] 0.95

$lowerEndpointMatrix
          a         b
a 0.2222222 0.3333333
b 0.5714286 0.1428571

$upperEndpointMatrix
          a         b
a 0.8111456 0.9222567
b 1.0000000 0.6839473

> 
> 
> 
> cleanEx()
> nameEx("noofVisitsDist")
> ### * noofVisitsDist
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: noofVisitsDist
> ### Title: return a joint pdf of the number of visits to the various states
> ###   of the DTMC
> ### Aliases: noofVisitsDist
> 
> ### ** Examples
> 
> transMatr<-matrix(c(0.4,0.6,.3,.7),nrow=2,byrow=TRUE)
> simpleMc<-new("markovchain", states=c("a","b"),
+              transitionMatrix=transMatr, 
+              name="simpleMc")   
> noofVisitsDist(simpleMc,5,"a")
       a        b 
0.348148 0.651852 
> 
> 
> 
> 
> cleanEx()
> nameEx("predictiveDistribution")
> ### * predictiveDistribution
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: predictiveDistribution
> ### Title: predictiveDistribution
> ### Aliases: predictiveDistribution
> 
> ### ** Examples
> 
> sequence<- c("a", "b", "a", "a", "a", "a", "b", "a", "b", "a", "b", "a", "a", 
+              "b", "b", "b", "a")
> hyperMatrix<-matrix(c(1, 2, 1, 4), nrow = 2,dimnames=list(c("a","b"),c("a","b")))
> predProb <- predictiveDistribution(sequence[1:10], sequence[11:17], hyperparam =hyperMatrix )
> hyperMatrix2<-hyperMatrix[c(2,1),c(2,1)]
> predProb2 <- predictiveDistribution(sequence[1:10], sequence[11:17], hyperparam =hyperMatrix2 )
> predProb2==predProb
[1] TRUE
> 
> 
> 
> cleanEx()
> nameEx("preproglucacon")
> ### * preproglucacon
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: preproglucacon
> ### Title: Preprogluccacon DNA protein bases sequences
> ### Aliases: preproglucacon
> ### Keywords: datasets
> 
> ### ** Examples
> 
> data(preproglucacon)
> preproglucaconMc<-markovchainFit(data=preproglucacon$preproglucacon)
> 
> 
> 
> cleanEx()
> nameEx("priorDistribution")
> ### * priorDistribution
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: priorDistribution
> ### Title: priorDistribution
> ### Aliases: priorDistribution
> 
> ### ** Examples
> 
> priorDistribution(matrix(c(0.5, 0.5, 0.5, 0.5), 
+                   nrow = 2, 
+                   dimnames = list(c("a", "b"), c("a", "b"))), 
+                   matrix(c(2, 2, 2, 2), 
+                   nrow = 2, 
+                   dimnames = list(c("a", "b"), c("a", "b"))))
        a         b 
0.4054651 0.4054651 
> 
> 
> 
> cleanEx()
> nameEx("probabilityatT")
> ### * probabilityatT
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: probabilityatT
> ### Title: Calculating probability from a ctmc object
> ### Aliases: probabilityatT
> 
> ### ** Examples
> 
> states <- c("a","b","c","d")
> byRow <- TRUE
> gen <- matrix(data = c(-1, 1/2, 1/2, 0, 1/4, -1/2, 0, 1/4, 1/6, 0, -1/3, 1/6, 0, 0, 0, 0),
+ nrow = 4,byrow = byRow, dimnames = list(states,states))
> ctmc <- new("ctmc",states = states, byrow = byRow, generator = gen, name = "testctmc")
> probabilityatT(ctmc,1,useRCpp = TRUE)
           a          b         c          d
a 0.41546882 0.24714119 0.2703605 0.06702946
b 0.12357060 0.63939068 0.0348290 0.20220972
c 0.09012017 0.02321933 0.7411205 0.14553997
d 0.00000000 0.00000000 0.0000000 1.00000000
> 
> 
> 
> 
> cleanEx()
> nameEx("rain")
> ### * rain
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rain
> ### Title: Alofi island daily rainfall
> ### Aliases: rain
> ### Keywords: datasets
> 
> ### ** Examples
> 
> data(rain)
> rainMc<-markovchainFit(data=rain$rain)
> 
> 
> 
> cleanEx()
> nameEx("rctmc")
> ### * rctmc
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rctmc
> ### Title: rctmc
> ### Aliases: rctmc
> 
> ### ** Examples
> 
> energyStates <- c("sigma", "sigma_star")
> byRow <- TRUE
> gen <- matrix(data = c(-3, 3, 1, -1), nrow = 2,
+              byrow = byRow, dimnames = list(energyStates, energyStates))
> molecularCTMC <- new("ctmc", states = energyStates, 
+                      byrow = byRow, generator = gen, 
+                      name = "Molecular Transition Model")   
> 
> statesDist <- c(0.8, 0.2)
> rctmc(n = Inf, ctmc = molecularCTMC, T = 1)
[[1]]
[1] "sigma"      "sigma_star" "sigma"      "sigma_star"

[[2]]
[1] 0.0000000 0.3938809 0.5336762 0.6408747

> rctmc(n = 5, ctmc = molecularCTMC, initDist = statesDist, include.T0 = FALSE)
[[1]]
[1] "sigma_star" "sigma"      "sigma_star" "sigma"      "sigma_star"

[[2]]
[1] 0.3188558 1.7921784 2.2047129 3.4274119 3.7789263

> 
> 
> 
> cleanEx()
> nameEx("rmarkovchain")
> ### * rmarkovchain
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rmarkovchain
> ### Title: Function to generate a sequence of states from homogeneous or
> ###   non-homogeneous Markov chains.
> ### Aliases: rmarkovchain
> 
> ### ** Examples
> 
> # define the markovchain object
> statesNames <- c("a", "b", "c")
> mcB <- new("markovchain", states = statesNames, 
+    transitionMatrix = matrix(c(0.2, 0.5, 0.3, 0, 0.2, 0.8, 0.1, 0.8, 0.1), 
+    nrow = 3, byrow = TRUE, dimnames = list(statesNames, statesNames)))
> 
> # show the sequence
> outs <- rmarkovchain(n = 100, object = mcB, what = "list")
> 
> 
> #define markovchainList object
> statesNames <- c("a", "b", "c")
> mcA <- new("markovchain", states = statesNames, transitionMatrix = 
+    matrix(c(0.2, 0.5, 0.3, 0, 0.2, 0.8, 0.1, 0.8, 0.1), nrow = 3, 
+    byrow = TRUE, dimnames = list(statesNames, statesNames)))
> mcB <- new("markovchain", states = statesNames, transitionMatrix = 
+    matrix(c(0.2, 0.5, 0.3, 0, 0.2, 0.8, 0.1, 0.8, 0.1), nrow = 3, 
+    byrow = TRUE, dimnames = list(statesNames, statesNames)))
> mcC <- new("markovchain", states = statesNames, transitionMatrix = 
+    matrix(c(0.2, 0.5, 0.3, 0, 0.2, 0.8, 0.1, 0.8, 0.1), nrow = 3, 
+    byrow = TRUE, dimnames = list(statesNames, statesNames)))
> mclist <- new("markovchainList", markovchains = list(mcA, mcB, mcC)) 
> 
> # show the list of sequence
> rmarkovchain(100, mclist, "list")
[[1]]
[1] "a" "c" "b"

[[2]]
[1] "b" "b" "c"

[[3]]
[1] "b" "c" "b"

[[4]]
[1] "b" "c" "b"

[[5]]
[1] "c" "c" "b"

[[6]]
[1] "c" "b" "c"

[[7]]
[1] "c" "b" "c"

[[8]]
[1] "c" "b" "c"

[[9]]
[1] "b" "c" "b"

[[10]]
[1] "b" "c" "b"

[[11]]
[1] "b" "c" "b"

[[12]]
[1] "c" "b" "b"

[[13]]
[1] "c" "b" "c"

[[14]]
[1] "c" "b" "c"

[[15]]
[1] "b" "c" "a"

[[16]]
[1] "c" "a" "b"

[[17]]
[1] "b" "c" "b"

[[18]]
[1] "b" "b" "c"

[[19]]
[1] "b" "c" "b"

[[20]]
[1] "b" "c" "b"

[[21]]
[1] "b" "b" "c"

[[22]]
[1] "b" "b" "c"

[[23]]
[1] "b" "c" "c"

[[24]]
[1] "c" "b" "b"

[[25]]
[1] "c" "b" "c"

[[26]]
[1] "c" "b" "c"

[[27]]
[1] "c" "b" "c"

[[28]]
[1] "b" "c" "c"

[[29]]
[1] "b" "c" "c"

[[30]]
[1] "b" "c" "b"

[[31]]
[1] "c" "c" "b"

[[32]]
[1] "b" "c" "a"

[[33]]
[1] "c" "b" "c"

[[34]]
[1] "c" "b" "c"

[[35]]
[1] "c" "b" "c"

[[36]]
[1] "b" "c" "b"

[[37]]
[1] "c" "b" "b"

[[38]]
[1] "c" "b" "c"

[[39]]
[1] "c" "b" "c"

[[40]]
[1] "b" "c" "b"

[[41]]
[1] "c" "b" "c"

[[42]]
[1] "c" "b" "c"

[[43]]
[1] "b" "c" "b"

[[44]]
[1] "b" "c" "b"

[[45]]
[1] "c" "b" "c"

[[46]]
[1] "b" "c" "b"

[[47]]
[1] "b" "c" "b"

[[48]]
[1] "b" "b" "c"

[[49]]
[1] "c" "b" "c"

[[50]]
[1] "a" "c" "b"

[[51]]
[1] "c" "b" "b"

[[52]]
[1] "a" "b" "c"

[[53]]
[1] "b" "b" "c"

[[54]]
[1] "b" "c" "b"

[[55]]
[1] "b" "c" "b"

[[56]]
[1] "b" "b" "b"

[[57]]
[1] "b" "c" "b"

[[58]]
[1] "b" "c" "a"

[[59]]
[1] "b" "c" "b"

[[60]]
[1] "b" "b" "c"

[[61]]
[1] "c" "b" "c"

[[62]]
[1] "c" "b" "c"

[[63]]
[1] "c" "b" "c"

[[64]]
[1] "b" "b" "c"

[[65]]
[1] "b" "c" "b"

[[66]]
[1] "b" "c" "a"

[[67]]
[1] "c" "b" "c"

[[68]]
[1] "c" "c" "b"

[[69]]
[1] "b" "c" "a"

[[70]]
[1] "b" "c" "b"

[[71]]
[1] "b" "c" "b"

[[72]]
[1] "a" "b" "b"

[[73]]
[1] "b" "b" "c"

[[74]]
[1] "b" "c" "b"

[[75]]
[1] "c" "b" "c"

[[76]]
[1] "a" "a" "c"

[[77]]
[1] "c" "b" "b"

[[78]]
[1] "b" "c" "b"

[[79]]
[1] "b" "c" "b"

[[80]]
[1] "a" "b" "c"

[[81]]
[1] "c" "b" "c"

[[82]]
[1] "a" "a" "a"

[[83]]
[1] "b" "c" "b"

[[84]]
[1] "a" "c" "b"

[[85]]
[1] "b" "c" "b"

[[86]]
[1] "c" "b" "c"

[[87]]
[1] "b" "c" "b"

[[88]]
[1] "b" "c" "b"

[[89]]
[1] "c" "b" "b"

[[90]]
[1] "c" "b" "c"

[[91]]
[1] "b" "c" "c"

[[92]]
[1] "b" "c" "b"

[[93]]
[1] "b" "c" "b"

[[94]]
[1] "b" "b" "c"

[[95]]
[1] "c" "b" "c"

[[96]]
[1] "c" "b" "c"

[[97]]
[1] "b" "b" "c"

[[98]]
[1] "a" "b" "c"

[[99]]
[1] "c" "b" "c"

[[100]]
[1] "b" "c" "b"

>      
> 
> 
> 
> cleanEx()
> nameEx("sales")
> ### * sales
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: sales
> ### Title: Sales Demand Sequences
> ### Aliases: sales
> ### Keywords: datasets
> 
> ### ** Examples
> 
> data("sales")
> # fitHighOrderMultivarMC(seqMat = sales, order = 2, Norm = 2)
> 
> 
> 
> 
> cleanEx()
> nameEx("setName")
> ### * setName
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: name<-
> ### Title: Method to set name of markovchain object
> ### Aliases: name<- name<-,markovchain-method
> 
> ### ** Examples
> 
> statesNames <- c("a", "b", "c")
> markovB <- new("markovchain", states = statesNames, transitionMatrix =
+                 matrix(c(0.2, 0.5, 0.3, 0, 1, 0, 0.1, 0.8, 0.1), nrow = 3,
+                 byrow = TRUE, dimnames=list(statesNames,statesNames)),
+                 name = "A markovchain Object" 
+ )
> name(markovB) <- "dangerous mc"
> 
> 
> 
> 
> cleanEx()
> nameEx("states")
> ### * states
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: states
> ### Title: Defined states of a transition matrix
> ### Aliases: states states,markovchain-method
> 
> ### ** Examples
> 
> statesNames <- c("a", "b", "c")
> markovB <- new("markovchain", states = statesNames, transitionMatrix =
+                 matrix(c(0.2, 0.5, 0.3, 0, 1, 0, 0.1, 0.8, 0.1), nrow = 3,
+                 byrow = TRUE, dimnames=list(statesNames,statesNames)),
+                 name = "A markovchain Object" 
+ )
> states(markovB)
[1] "a" "b" "c"
> names(markovB)
[1] "a" "b" "c"
> 
> 
> 
> 
> cleanEx()
> nameEx("statisticalTests")
> ### * statisticalTests
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: verifyMarkovProperty
> ### Title: Various functions to perform statistical inference of DTMC
> ### Aliases: verifyMarkovProperty assessOrder assessStationarity
> ###   verifyEmpiricalToTheoretical verifyHomogeneity
> 
> ### ** Examples
> 
> sequence <- c("a", "b", "a", "a", "a", "a", "b", "a", "b",
+               "a", "b", "a", "a", "b", "b", "b", "a")
> mcFit <- markovchainFit(data = sequence, byrow = FALSE)
> verifyMarkovProperty(sequence)
Testing markovianity property on given data sequence
Chi - square statistic is: 0.28 
Degrees of freedom are: 5 
And corresponding p-value is: 0.9980024 
> assessOrder(sequence)
Warning in assessOrder(sequence) :
  The accuracy of the statistical inference functions has been questioned. It will be thoroughly investigated in future versions of the package.
Warning in chisq.test(mat) : Chi-squared approximation may be incorrect
Warning in chisq.test(mat) : Chi-squared approximation may be incorrect
The assessOrder test statistic is:  1.55307e-31 
The Chi-Square d.f. are:  2 
The p-value is:  1 
> assessStationarity(sequence, 1)
Warning in assessStationarity(sequence, 1) :
  The accuracy of the statistical inference functions has been questioned. It will be thoroughly investigated in future versions of the package.
Warning in chisq.test(mat) : Chi-squared approximation may be incorrect
Warning in chisq.test(mat) : Chi-squared approximation may be incorrect
The assessStationarity test statistic is:  0.1960191 
The Chi-Square d.f. are:  0 
The p-value is:  0 
> 
> 
> 
> #Example taken from Kullback Kupperman Tests for Contingency Tables and Markov Chains
> 
> sequence<-c(0,1,2,2,1,0,0,0,0,0,0,1,2,2,2,1,0,0,1,0,0,0,0,0,0,1,1,
+ 2,0,0,2,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,2,1,0,
+ 0,2,1,0,0,0,0,0,0,1,1,1,2,2,0,0,2,1,1,1,1,2,1,1,1,1,1,1,1,1,1,0,2,
+ 0,1,1,0,0,0,1,2,2,0,0,0,0,0,0,2,2,2,1,1,1,1,0,1,1,1,1,0,0,2,1,1,
+ 0,0,0,0,0,2,2,1,1,1,1,1,2,1,2,0,0,0,1,2,2,2,0,0,0,1,1)
> 
> mc=matrix(c(5/8,1/4,1/8,1/4,1/2,1/4,1/4,3/8,3/8),byrow=TRUE, nrow=3)
> rownames(mc)<-colnames(mc)<-0:2; theoreticalMc<-as(mc, "markovchain")
> 
> verifyEmpiricalToTheoretical(data=sequence,object=theoreticalMc)
Testing whether the
   0  1  2
0 51 11  8
1 12 31  9
2  6 11 10
transition matrix is compatible with
      0     1     2
0 0.625 0.250 0.125
1 0.250 0.500 0.250
2 0.250 0.375 0.375
[1] "theoretical transition matrix"
ChiSq statistic is 6.551795 d.o.f are 6 corresponding p-value is 0.3642899 
$statistic
       0 
6.551795 

$dof
[1] 6

$pvalue
        0 
0.3642899 

> 
> 
> data(kullback)
> verifyHomogeneity(inputList=kullback,verbose=TRUE)
Warning in verifyHomogeneity(inputList = kullback, verbose = TRUE) :
  The accuracy of the statistical inference functions has been questioned. It will be thoroughly investigated in future versions of the package.
Testing homogeneity of DTMC underlying input list 
ChiSq statistic is 275.9963 d.o.f are 35 corresponding p-value is 0 
$statistic
[1] 275.9963

$dof
[1] 35

$pvalue
[1] 0

> 
> 
> 
> 
> cleanEx()
> nameEx("steadyStates")
> ### * steadyStates
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: steadyStates
> ### Title: Stationary states of a 'markovchain' object
> ### Aliases: steadyStates
> 
> ### ** Examples
> 
> statesNames <- c("a", "b", "c")
> markovB <- new("markovchain", states = statesNames, transitionMatrix =
+                 matrix(c(0.2, 0.5, 0.3, 0, 1, 0, 0.1, 0.8, 0.1), nrow = 3,
+                 byrow = TRUE, dimnames=list(statesNames,statesNames)),
+                name = "A markovchain Object" 
+ )       
> steadyStates(markovB)
     a b c
[1,] 0 1 0
> 
> 
> 
> 
> cleanEx()
> nameEx("structuralAnalysis")
> ### * structuralAnalysis
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: period
> ### Title: Various function to perform structural analysis of DTMC
> ### Aliases: period communicatingClasses transientStates recurrentStates
> ###   absorbingStates transientClasses recurrentClasses canonicForm
> 
> ### ** Examples
> 
> statesNames <- c("a", "b", "c")
> mc <- new("markovchain", states = statesNames, transitionMatrix =
+           matrix(c(0.2, 0.5, 0.3,
+                    0,   1,   0,
+                    0.1, 0.8, 0.1), nrow = 3, byrow = TRUE,
+                  dimnames = list(statesNames, statesNames))
+          )
> 
> communicatingClasses(mc)
[[1]]
[1] "a" "c"

[[2]]
[1] "b"

> recurrentClasses(mc)
[[1]]
[1] "b"

> recurrentClasses(mc)
[[1]]
[1] "b"

> absorbingStates(mc)
[1] "b"
> transientStates(mc)
[1] "a" "c"
> recurrentStates(mc)
[1] "b"
> canonicForm(mc)
Unnamed Markov chain 
 A  3 - dimensional discrete Markov Chain defined by the following states: 
 b, a, c 
 The transition matrix  (by rows)  is defined as follows: 
    b   a   c
b 1.0 0.0 0.0
a 0.5 0.2 0.3
c 0.8 0.1 0.1

> 
> # periodicity analysis
> A <- matrix(c(0, 1, 0, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0, 0.5, 0, 0, 1, 0), 
+             nrow = 4, ncol = 4, byrow = TRUE)
> mcA <- new("markovchain", states = c("a", "b", "c", "d"), 
+           transitionMatrix = A,
+           name = "A")
> 
> is.irreducible(mcA) #true
[1] TRUE
> period(mcA) #2
[1] 2
> 
> # periodicity analysis
> B <- matrix(c(0, 0, 1/2, 1/4, 1/4, 0, 0,
+                    0, 0, 1/3, 0, 2/3, 0, 0,
+                    0, 0, 0, 0, 0, 1/3, 2/3,
+                    0, 0, 0, 0, 0, 1/2, 1/2,
+                    0, 0, 0, 0, 0, 3/4, 1/4,
+                    1/2, 1/2, 0, 0, 0, 0, 0,
+                    1/4, 3/4, 0, 0, 0, 0, 0), byrow = TRUE, ncol = 7)
> mcB <- new("markovchain", transitionMatrix = B)
> period(mcB)
[1] 3
> 
> 
> 
> 
> cleanEx()
> nameEx("tm_abs")
> ### * tm_abs
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: tm_abs
> ### Title: Single Year Corporate Credit Rating Transititions
> ### Aliases: tm_abs
> ### Keywords: datasets
> 
> ### ** Examples
> 
> data(tm_abs)
> 
> 
> 
> cleanEx()
> nameEx("transition2Generator")
> ### * transition2Generator
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: transition2Generator
> ### Title: Return the generator matrix for a corresponding transition
> ###   matrix
> ### Aliases: transition2Generator
> 
> ### ** Examples
> 
> mymatr <- matrix(c(.4, .6, .1, .9), nrow = 2, byrow = TRUE)
> Q <- transition2Generator(P = mymatr)
> expm::expm(Q)
     [,1] [,2]
[1,]  0.4  0.6
[2,]  0.1  0.9
>  
> 
> 
> 
> cleanEx()
> nameEx("transitionProbability")
> ### * transitionProbability
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: transitionProbability
> ### Title: Function to get the transition probabilities from initial to
> ###   subsequent states.
> ### Aliases: transitionProbability transitionProbability,markovchain-method
> 
> ### ** Examples
> 
> statesNames <- c("a", "b", "c")
> markovB <- new("markovchain", states = statesNames, transitionMatrix =
+                 matrix(c(0.2, 0.5, 0.3, 0, 1, 0, 0.1, 0.8, 0.1), nrow = 3,
+                 byrow = TRUE, dimnames=list(statesNames,statesNames)),
+                name = "A markovchain Object" 
+ )    
> transitionProbability(markovB,"b", "c")
[1] 0
> 
> 
> 
> ### * <FOOTER>
> ###
> cleanEx()
> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  2.4 1.864 2.175 0 0 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
