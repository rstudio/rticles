
R version 4.1.1 (2021-08-10) -- "Kick Things"
Copyright (C) 2021 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "worcs"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> library('worcs')
[0;34mWelcome to WORCS: Workflow for Open Reproducible Code in Science. Please read the tutorial before using this package, and consider citing it:
  Van Lissa and colleagues (2020) <doi:10.17605/OSF.IO/ZCVBS>[0m
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("add_manuscript")
> ### * add_manuscript
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: add_manuscript
> ### Title: Add Rmarkdown manuscript
> ### Aliases: add_manuscript
> 
> ### ** Examples
> 
> the_test <- "worcs_manuscript"
> old_wd <- getwd()
> dir.create(file.path(tempdir(), the_test))
> file.create(file.path(tempdir(), the_test, ".worcs"))
[1] TRUE
> add_manuscript(file.path(tempdir(), the_test),
+               manuscript = "None")
âœ” Creating manuscript files.
> setwd(old_wd)
> unlink(file.path(tempdir(), the_test))
> 
> 
> 
> cleanEx()
> nameEx("add_preregistration")
> ### * add_preregistration
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: add_preregistration
> ### Title: Add Rmarkdown preregistration
> ### Aliases: add_preregistration
> 
> ### ** Examples
> 
> the_test <- "worcs_prereg"
> old_wd <- getwd()
> dir.create(file.path(tempdir(), the_test))
> file.create(file.path(tempdir(), the_test, ".worcs"))
[1] TRUE
> add_preregistration(file.path(tempdir(), the_test),
+                     preregistration = "cos_prereg")
âœ” Creating preregistration files.
> setwd(old_wd)
> unlink(file.path(tempdir(), the_test))
> 
> 
> 
> cleanEx()
> nameEx("add_synthetic")
> ### * add_synthetic
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: add_synthetic
> ### Title: Add synthetic data to WORCS project
> ### Aliases: add_synthetic
> 
> ### ** Examples
> 
> # Create directory to run the example
> old_wd <- getwd()
> test_dir <- file.path(tempdir(), "add_synthetic")
> dir.create(test_dir)
> setwd(test_dir)
> worcs:::write_worcsfile(".worcs")
> # Prepare data
> df <- iris[1:3, ]
> # Run closed_data without synthetic
> closed_data(df, codebook = NULL, synthetic = FALSE)
âœ” Storing original data in 'df.csv' and updating the checksum in '.worcs'.
âœ” Creating /tmp/RtmpfS0v1h/add_synthetic/README.md.
âœ” Updating '.gitignore'.
âœ” Storing value labels in 'value_labels_df.yml'.
> # Manually add synthetic
> add_synthetic(df, original_name = "df.csv")
âœ” Storing synthetic data in 'synthetic_df.csv' and updating the checksum in '.worcs'.
âœ” Updating '.gitignore'.
âœ” Updating /tmp/RtmpfS0v1h/add_synthetic/README.md.
> # Remove original from file and environment
> file.remove("df.csv")
[1] TRUE
> rm(df)
> # See that load_data() now loads the synthetic file
> load_data()
âœ” Loading synthetic data from 'synthetic_df.csv'.
âœ– No valid codebook found.
> # Cleaning example directory
> setwd(old_wd)
> unlink(test_dir, recursive = TRUE)
> 
> 
> 
> cleanEx()
> nameEx("check_worcs")
> ### * check_worcs
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: check_worcs
> ### Title: Evaluate project with respect to WORCS checklist
> ### Aliases: check_worcs
> 
> ### ** Examples
> 
> example_dir <- file.path(tempdir(), "badge")
> dir.create(example_dir)
> write("a", file.path(example_dir, ".worcs"))
> check_worcs(path = example_dir)
âœ– Does the project have a README.md file?
âœ– Does the project have a LICENSE file?
âœ– Does the project cite any references in 'manuscript.Rmd' or 'preregistration.Rmd'?
âœ– Does the project have a public* 'data.csv' or 'synthetic_data.csv' file? (*public: version controlled in 'Git')
âœ– Are the data checksums up to date?
âœ– Does the project contain any '.R' code files?
âœ– Does the project have a preregistration?
âœ– Does the project have a 'Git' repository?
âœ– Is the 'Git' repository connected to a remote repository (e.g., 'GitHub')?
          category              name
1    documentation            readme
2    documentation           license
3         citation          citation
4         citation     comprehensive
5             data              data
6             data    data_checksums
7             code              code
8             code code_reproducible
9        materials         materials
10          design            design
11        analysis          analysis
12 preregistration   preregistration
13 preregistration   prereg_analysis
14             git          git_repo
15             git        has_remote
                                                                                                         description
1                                                                            Does the project have a README.md file?
2                                                                              Does the project have a LICENSE file?
3                                 Does the project cite any references in 'manuscript.Rmd' or 'preregistration.Rmd'?
4            Does the project cite all literature, data sources, materials, and methods (including R-packages) used?
5    Does the project have a public* 'data.csv' or 'synthetic_data.csv' file? (*public: version controlled in 'Git')
6                                                                                 Are the data checksums up to date?
7                                                                      Does the project contain any '.R' code files?
8  Can the entire project be reproduced by running a single file (e.g.,'manuscript.Rmd', 'run_me.R', or a Makefile)?
9                                            Any new materials are shared openly; existing materials are referenced.
10                                                                       Details of the study design are documented.
11                                                                           Details of the analysis are documented.
12                                                                          Does the project have a preregistration?
13                                     Does the preregistration contain detailed analysis plans or preliminary code?
14                                                                         Does the project have a 'Git' repository?
15                                        Is the 'Git' repository connected to a remote repository (e.g., 'GitHub')?
   importance check  pass
1   essential  TRUE FALSE
2   essential  TRUE FALSE
3    optional  TRUE FALSE
4    optional FALSE FALSE
5   essential  TRUE FALSE
6   essential  TRUE FALSE
7   essential  TRUE FALSE
8    optional FALSE FALSE
9    optional FALSE FALSE
10  essential FALSE FALSE
11  essential FALSE FALSE
12   optional  TRUE FALSE
13   optional FALSE FALSE
14  essential  TRUE FALSE
15  essential  TRUE FALSE
> 
> 
> 
> cleanEx()
> nameEx("check_worcs_installation")
> ### * check_worcs_installation
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: check_worcs_installation
> ### Title: Check worcs dependencies
> ### Aliases: check_worcs_installation check_dependencies check_git
> ###   check_github check_ssh check_tinytext check_rmarkdown check_renv
> 
> ### ** Examples
> 
> check_worcs_installation("none")
> 
> 
> 
> cleanEx()
> nameEx("cite_all")
> ### * cite_all
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: cite_all
> ### Title: Comprehensive citation Knit function for 'RStudio'
> ### Aliases: cite_all
> 
> ### ** Examples
> 
> # NOTE: Do not use this function interactively, as in the example below.
> # Only specify it as custom knit function in an 'R Markdown' file, like so:
> # knit: worcs::cite_all
> 
> if (rmarkdown::pandoc_available("2.0")){
+   file_name <- file.path(tempdir(), "citeall.Rmd")
+   loc <- rmarkdown::draft(file_name,
+                           template = "github_document",
+                           package = "rmarkdown",
+                           create_dir = FALSE,
+                           edit = FALSE)
+   write(c("", "Optional reference: @reference2020"),
+         file = file_name, append = TRUE)
+   cite_all(file_name)
+ }


processing file: citeall.Rmd
  ordinary text without R code

label: setup (with options) 
List of 1
 $ include: logi FALSE

  ordinary text without R code

label: cars
  ordinary text without R code

label: pressure (with options) 
List of 1
 $ echo: logi FALSE

  ordinary text without R code

output file: citeall.knit.md

/usr/bin/pandoc +RTS -K512m -RTS citeall.knit.md --to gfm --from markdown+autolink_bare_uris+tex_math_single_backslash --output citeall.md --atx-headers --template /opt/R/4.1.1/lib/R/site-library/rmarkdown/rmarkdown/templates/github_document/resources/default.md '--webtex=https://latex.codecogs.com/png.image?%5Cdpi%7B110%7D&space;%5Cbg_white&space;' 
/usr/bin/pandoc +RTS -K512m -RTS citeall.md --to html4 --from gfm --output citeall.html --self-contained --highlight-style pygments --template /opt/R/4.1.1/lib/R/site-library/rmarkdown/rmarkdown/templates/github_document/resources/preview.html --variable 'github-markdown-css:/opt/R/4.1.1/lib/R/site-library/rmarkdown/rmarkdown/templates/github_document/resources/github.css' --metadata pagetitle=PREVIEW '--webtex=https://latex.codecogs.com/svg.image?' 

Preview created: citeall.html

Output created: citeall.md
> 
> 
> 
> cleanEx()
> nameEx("cite_essential")
> ### * cite_essential
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: cite_essential
> ### Title: Essential citations Knit function for 'RStudio'
> ### Aliases: cite_essential
> 
> ### ** Examples
> 
> # NOTE: Do not use this function interactively, as in the example below.
> # Only specify it as custom knit function in an R Markdown file, like so:
> # knit: worcs::cite_all
> 
> if (rmarkdown::pandoc_available("2.0")){
+   file_name <- tempfile("citeessential", fileext = ".Rmd")
+   rmarkdown::draft(file_name,
+                    template = "github_document",
+                    package = "rmarkdown",
+                    create_dir = FALSE,
+                    edit = FALSE)
+   write(c("", "Optional reference: @reference2020"),
+         file = file_name, append = TRUE)
+   cite_essential(file_name)
+ }


processing file: citeessential38fc61a4050c.Rmd
  ordinary text without R code

label: setup (with options) 
List of 1
 $ include: logi FALSE

  ordinary text without R code

label: cars
  ordinary text without R code

label: pressure (with options) 
List of 1
 $ echo: logi FALSE

  ordinary text without R code

output file: citeessential38fc61a4050c.knit.md

/usr/bin/pandoc +RTS -K512m -RTS citeessential38fc61a4050c.knit.md --to gfm --from markdown+autolink_bare_uris+tex_math_single_backslash --output citeessential38fc61a4050c.md --atx-headers --template /opt/R/4.1.1/lib/R/site-library/rmarkdown/rmarkdown/templates/github_document/resources/default.md '--webtex=https://latex.codecogs.com/png.image?%5Cdpi%7B110%7D&space;%5Cbg_white&space;' 
/usr/bin/pandoc +RTS -K512m -RTS citeessential38fc61a4050c.md --to html4 --from gfm --output citeessential38fc61a4050c.html --self-contained --highlight-style pygments --template /opt/R/4.1.1/lib/R/site-library/rmarkdown/rmarkdown/templates/github_document/resources/preview.html --variable 'github-markdown-css:/opt/R/4.1.1/lib/R/site-library/rmarkdown/rmarkdown/templates/github_document/resources/github.css' --metadata pagetitle=PREVIEW '--webtex=https://latex.codecogs.com/svg.image?' 

Preview created: citeessential38fc61a4050c.html

Output created: citeessential38fc61a4050c.md
> 
> 
> 
> cleanEx()
> nameEx("closed_data")
> ### * closed_data
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: closed_data
> ### Title: Use closed data in WORCS project
> ### Aliases: closed_data
> 
> ### ** Examples
> 
> old_wd <- getwd()
> test_dir <- file.path(tempdir(), "data")
> dir.create(test_dir)
> setwd(test_dir)
> worcs:::write_worcsfile(".worcs")
> df <- iris[1:3, ]
> closed_data(df, codebook = NULL)
âœ” Storing original data in 'df.csv' and updating the checksum in '.worcs'.
âœ” Creating /tmp/RtmpfS0v1h/data/README.md.
âœ” Generating synthetic data for public use. Ensure that no identifying information is included.
  |                                                                              |                                                                      |   0%  |                                                                              |==============                                                        |  20%  |                                                                              |============================                                          |  40%  |                                                                              |==========================================                            |  60%  |                                                                              |========================================================              |  80%Warning: Dropped unused factor level(s) in dependent variable: versicolor, virginica.
  |                                                                              |======================================================================| 100%
âœ” Storing synthetic data in 'synthetic_df.csv' and updating the checksum in '.worcs'.
âœ” Updating '.gitignore'.
âœ” Updating /tmp/RtmpfS0v1h/data/README.md.
âœ” Updating '.gitignore'.
âœ” Storing value labels in 'value_labels_df.yml'.
> setwd(old_wd)
> unlink(test_dir, recursive = TRUE)
> 
> 
> 
> cleanEx()
> nameEx("codebook")
> ### * codebook
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: make_codebook
> ### Title: Create codebook for a dataset
> ### Aliases: make_codebook
> 
> ### ** Examples
> 
> if(rmarkdown::pandoc_available("2.0")){
+   library(rmarkdown)
+   library(knitr)
+   filename <- tempfile("codebook", fileext = ".Rmd")
+   make_codebook(iris, filename = filename, csv_file = NULL)
+   unlink(c(
+     ".worcs",
+     filename,
+     gsub("\\.Rmd", "\\.md", filename),
+     gsub("\\.Rmd", "\\.html", filename),
+     gsub("\\.Rmd", "_files", filename)
+   ), recursive = TRUE)
+ }
> 
> 
> 
> cleanEx()

detaching â€˜package:knitrâ€™, â€˜package:rmarkdownâ€™

> nameEx("data_label")
> ### * data_label
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: data_label
> ### Title: Label factor variables using metadata
> ### Aliases: data_label
> 
> ### ** Examples
> 
> ## Not run: 
> ##D if(interactive()){
> ##D  labs <- list(x = list(class = "factor", `1` = "a", `2` = "b"))
> ##D  df <- data.frame(x = 1:2)
> ##D  data_label(df, value_labels = labs)
> ##D  }
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("data_unlabel")
> ### * data_unlabel
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: data_unlabel
> ### Title: Drop value labels
> ### Aliases: data_unlabel
> 
> ### ** Examples
> 
> ## Not run: 
> ##D if(interactive()){
> ##D  df <- data.frame(x = factor(c("a", "b")))
> ##D  data_unlabel(df)
> ##D  }
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("descriptives")
> ### * descriptives
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: descriptives
> ### Title: Describe a dataset
> ### Aliases: descriptives
> 
> ### ** Examples
> 
> descriptives(iris)
          name    type   n missing unique     mean median  mode mode_value
1 Sepal.Length numeric 150       0     35 5.843333   5.80  5.80       <NA>
2  Sepal.Width numeric 150       0     23 3.057333   3.00  3.00       <NA>
3 Petal.Length numeric 150       0     43 3.758000   4.35  4.35       <NA>
4  Petal.Width numeric 150       0     22 1.199333   1.30  1.30       <NA>
5      Species  factor 150       0      4       NA     NA 50.00     setosa
         sd         v min max range       skew   skew_2se       kurt   kurt_2se
1 0.8280661        NA 4.3 7.9   3.6  0.3086407  0.7792448 -0.6058125 -0.7696120
2 0.4358663        NA 2.0 4.4   2.4  0.3126147  0.7892781  0.1387047  0.1762076
3 1.7652982        NA 1.0 6.9   5.9 -0.2694109 -0.6801988 -1.4168574 -1.7999470
4 0.7622377        NA 0.1 2.5   2.4 -0.1009166 -0.2547904 -1.3581792 -1.7254034
5        NA 0.6666667  NA  NA    NA         NA         NA         NA         NA
> 
> 
> 
> cleanEx()
> nameEx("export_project")
> ### * export_project
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: export_project
> ### Title: Export project to .zip file
> ### Aliases: export_project
> 
> ### ** Examples
> 
> export_project(worcs_directory = tempdir())
Warning in file(file, "rt", encoding = fileEncoding) :
  cannot open file '/tmp/RtmpfS0v1h/.worcs': No such file or directory
âœ– No '.worcs' file found; not a WORCS project, or the working directory has been changed.
> 
> 
> 
> cleanEx()
> nameEx("git_ignore")
> ### * git_ignore
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: git_ignore
> ### Title: Modify .gitignore file
> ### Aliases: git_ignore
> 
> ### ** Examples
> 
> dir.create(".git")
> git_ignore("ignorethis.file")
> unlink(".git", recursive = TRUE)
> file.remove(".gitignore")
[1] TRUE
> 
> 
> 
> cleanEx()
> nameEx("git_update")
> ### * git_update
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: git_update
> ### Title: Add, commit, and push changes.
> ### Aliases: git_update
> 
> ### ** Examples
> 
> git_update()
âœ– Not a 'Git' repository.
âœ– Could not add files to staging area of 'Git' repository.
âœ– Could not commit staged files to 'Git' repository.
âœ– Could not push local commits to remote repository.
âœ– Could not add files to staging area of 'Git' repository.
could not find repository from '/tmp/workdir/worcs/new/worcs.Rcheck'âœ– Could not commit staged files to 'Git' repository.
could not find repository from '/tmp/workdir/worcs/new/worcs.Rcheck'âœ– Could not push local commits to remote repository.
could not find repository from '/tmp/workdir/worcs/new/worcs.Rcheck'> 
> 
> 
> cleanEx()
> nameEx("git_user")
> ### * git_user
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: git_user
> ### Title: Set global 'Git' credentials
> ### Aliases: git_user
> 
> ### ** Examples
> 
> do.call(git_user, worcs:::get_user())
To set the 'Git' username and email, call 'git_user()' with the argument 'overwrite = TRUE'.
> 
> 
> 
> cleanEx()
> nameEx("has_git_user")
> ### * has_git_user
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: has_git_user
> ### Title: Check whether global 'Git' credentials exist
> ### Aliases: has_git_user
> 
> ### ** Examples
> 
> has_git_user()
[1] TRUE
> 
> 
> 
> cleanEx()
> nameEx("load_data")
> ### * load_data
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: load_data
> ### Title: Load WORCS project data
> ### Aliases: load_data
> 
> ### ** Examples
> 
> test_dir <- file.path(tempdir(), "loaddata")
> old_wd <- getwd()
> dir.create(test_dir)
> setwd(test_dir)
> worcs:::write_worcsfile(".worcs")
> df <- iris[1:5, ]
> suppressWarnings(closed_data(df, codebook = NULL))
âœ” Storing original data in 'df.csv' and updating the checksum in '.worcs'.
âœ” Creating /tmp/RtmpfS0v1h/loaddata/README.md.
âœ” Generating synthetic data for public use. Ensure that no identifying information is included.
  |                                                                              |                                                                      |   0%  |                                                                              |==============                                                        |  20%  |                                                                              |============================                                          |  40%  |                                                                              |==========================================                            |  60%  |                                                                              |========================================================              |  80%  |                                                                              |======================================================================| 100%
âœ” Storing synthetic data in 'synthetic_df.csv' and updating the checksum in '.worcs'.
âœ” Updating '.gitignore'.
âœ” Updating /tmp/RtmpfS0v1h/loaddata/README.md.
âœ” Updating '.gitignore'.
âœ” Storing value labels in 'value_labels_df.yml'.
> load_data()
âœ” Loading original data from 'df.csv'.
âœ– No valid codebook found.
Warning in load_data() :
  Object 'df' already exists in the environment designated by 'envir', and will be replaced with the contents of 'df.csv'.
> data
function (..., list = character(), package = NULL, lib.loc = NULL, 
    verbose = getOption("verbose"), envir = .GlobalEnv, overwrite = TRUE) 
{
    fileExt <- function(x) {
        db <- grepl("\\.[^.]+\\.(gz|bz2|xz)$", x)
        ans <- sub(".*\\.", "", x)
        ans[db] <- sub(".*\\.([^.]+\\.)(gz|bz2|xz)$", "\\1\\2", 
            x[db])
        ans
    }
    my_read_table <- function(...) {
        lcc <- Sys.getlocale("LC_COLLATE")
        on.exit(Sys.setlocale("LC_COLLATE", lcc))
        Sys.setlocale("LC_COLLATE", "C")
        read.table(...)
    }
    names <- c(as.character(substitute(list(...))[-1L]), list)
    if (!is.null(package)) {
        if (!is.character(package)) 
            stop("'package' must be a character string or NULL")
        if (FALSE) {
            if (any(package %in% "base")) 
                warning("datasets have been moved from package 'base' to package 'datasets'")
            if (any(package %in% "stats")) 
                warning("datasets have been moved from package 'stats' to package 'datasets'")
            package[package %in% c("base", "stats")] <- "datasets"
        }
    }
    paths <- find.package(package, lib.loc, verbose = verbose)
    if (is.null(lib.loc)) 
        paths <- c(path.package(package, TRUE), if (!length(package)) getwd(), 
            paths)
    paths <- unique(normalizePath(paths[file.exists(paths)]))
    paths <- paths[dir.exists(file.path(paths, "data"))]
    dataExts <- tools:::.make_file_exts("data")
    if (length(names) == 0L) {
        db <- matrix(character(), nrow = 0L, ncol = 4L)
        for (path in paths) {
            entries <- NULL
            packageName <- if (file_test("-f", file.path(path, 
                "DESCRIPTION"))) 
                basename(path)
            else "."
            if (file_test("-f", INDEX <- file.path(path, "Meta", 
                "data.rds"))) {
                entries <- readRDS(INDEX)
            }
            else {
                dataDir <- file.path(path, "data")
                entries <- tools::list_files_with_type(dataDir, 
                  "data")
                if (length(entries)) {
                  entries <- unique(tools::file_path_sans_ext(basename(entries)))
                  entries <- cbind(entries, "")
                }
            }
            if (NROW(entries)) {
                if (is.matrix(entries) && ncol(entries) == 2L) 
                  db <- rbind(db, cbind(packageName, dirname(path), 
                    entries))
                else warning(gettextf("data index for package %s is invalid and will be ignored", 
                  sQuote(packageName)), domain = NA, call. = FALSE)
            }
        }
        colnames(db) <- c("Package", "LibPath", "Item", "Title")
        footer <- if (missing(package)) 
            paste0("Use ", sQuote(paste("data(package =", ".packages(all.available = TRUE))")), 
                "\n", "to list the data sets in all *available* packages.")
        else NULL
        y <- list(title = "Data sets", header = NULL, results = db, 
            footer = footer)
        class(y) <- "packageIQR"
        return(y)
    }
    paths <- file.path(paths, "data")
    for (name in names) {
        found <- FALSE
        for (p in paths) {
            tmp_env <- if (overwrite) 
                envir
            else new.env()
            if (file_test("-f", file.path(p, "Rdata.rds"))) {
                rds <- readRDS(file.path(p, "Rdata.rds"))
                if (name %in% names(rds)) {
                  found <- TRUE
                  if (verbose) 
                    message(sprintf("name=%s:\t found in Rdata.rds", 
                      name), domain = NA)
                  thispkg <- sub(".*/([^/]*)/data$", "\\1", p)
                  thispkg <- sub("_.*$", "", thispkg)
                  thispkg <- paste0("package:", thispkg)
                  objs <- rds[[name]]
                  lazyLoad(file.path(p, "Rdata"), envir = tmp_env, 
                    filter = function(x) x %in% objs)
                  break
                }
                else if (verbose) 
                  message(sprintf("name=%s:\t NOT found in names() of Rdata.rds, i.e.,\n\t%s\n", 
                    name, paste(names(rds), collapse = ",")), 
                    domain = NA)
            }
            if (file_test("-f", file.path(p, "Rdata.zip"))) {
                warning("zipped data found for package ", sQuote(basename(dirname(p))), 
                  ".\nThat is defunct, so please re-install the package.", 
                  domain = NA)
                if (file_test("-f", fp <- file.path(p, "filelist"))) 
                  files <- file.path(p, scan(fp, what = "", quiet = TRUE))
                else {
                  warning(gettextf("file 'filelist' is missing for directory %s", 
                    sQuote(p)), domain = NA)
                  next
                }
            }
            else {
                files <- list.files(p, full.names = TRUE)
            }
            files <- files[grep(name, files, fixed = TRUE)]
            if (length(files) > 1L) {
                o <- match(fileExt(files), dataExts, nomatch = 100L)
                paths0 <- dirname(files)
                paths0 <- factor(paths0, levels = unique(paths0))
                files <- files[order(paths0, o)]
            }
            if (length(files)) {
                for (file in files) {
                  if (verbose) 
                    message("name=", name, ":\t file= ...", .Platform$file.sep, 
                      basename(file), "::\t", appendLF = FALSE, 
                      domain = NA)
                  ext <- fileExt(file)
                  if (basename(file) != paste0(name, ".", ext)) 
                    found <- FALSE
                  else {
                    found <- TRUE
                    zfile <- file
                    zipname <- file.path(dirname(file), "Rdata.zip")
                    if (file.exists(zipname)) {
                      Rdatadir <- tempfile("Rdata")
                      dir.create(Rdatadir, showWarnings = FALSE)
                      topic <- basename(file)
                      rc <- .External(C_unzip, zipname, topic, 
                        Rdatadir, FALSE, TRUE, FALSE, FALSE)
                      if (rc == 0L) 
                        zfile <- file.path(Rdatadir, topic)
                    }
                    if (zfile != file) 
                      on.exit(unlink(zfile))
                    switch(ext, R = , r = {
                      library("utils")
                      sys.source(zfile, chdir = TRUE, envir = tmp_env)
                    }, RData = , rdata = , rda = load(zfile, 
                      envir = tmp_env), TXT = , txt = , tab = , 
                      tab.gz = , tab.bz2 = , tab.xz = , txt.gz = , 
                      txt.bz2 = , txt.xz = assign(name, my_read_table(zfile, 
                        header = TRUE, as.is = FALSE), envir = tmp_env), 
                      CSV = , csv = , csv.gz = , csv.bz2 = , 
                      csv.xz = assign(name, my_read_table(zfile, 
                        header = TRUE, sep = ";", as.is = FALSE), 
                        envir = tmp_env), found <- FALSE)
                  }
                  if (found) 
                    break
                }
                if (verbose) 
                  message(if (!found) 
                    "*NOT* ", "found", domain = NA)
            }
            if (found) 
                break
        }
        if (!found) {
            warning(gettextf("data set %s not found", sQuote(name)), 
                domain = NA)
        }
        else if (!overwrite) {
            for (o in ls(envir = tmp_env, all.names = TRUE)) {
                if (exists(o, envir = envir, inherits = FALSE)) 
                  warning(gettextf("an object named %s already exists and will not be overwritten", 
                    sQuote(o)))
                else assign(o, get(o, envir = tmp_env, inherits = FALSE), 
                  envir = envir)
            }
            rm(tmp_env)
        }
    }
    invisible(names)
}
<bytecode: 0x55787abd4ca0>
<environment: namespace:utils>
> rm("data")
Warning in rm("data") : object 'data' not found
> file.remove("data.csv")
Warning in file.remove("data.csv") :
  cannot remove file 'data.csv', reason 'No such file or directory'
[1] FALSE
> load_data()
âœ” Loading original data from 'df.csv'.
âœ– No valid codebook found.
Warning in load_data() :
  Object 'df' already exists in the environment designated by 'envir', and will be replaced with the contents of 'df.csv'.
> data
function (..., list = character(), package = NULL, lib.loc = NULL, 
    verbose = getOption("verbose"), envir = .GlobalEnv, overwrite = TRUE) 
{
    fileExt <- function(x) {
        db <- grepl("\\.[^.]+\\.(gz|bz2|xz)$", x)
        ans <- sub(".*\\.", "", x)
        ans[db] <- sub(".*\\.([^.]+\\.)(gz|bz2|xz)$", "\\1\\2", 
            x[db])
        ans
    }
    my_read_table <- function(...) {
        lcc <- Sys.getlocale("LC_COLLATE")
        on.exit(Sys.setlocale("LC_COLLATE", lcc))
        Sys.setlocale("LC_COLLATE", "C")
        read.table(...)
    }
    names <- c(as.character(substitute(list(...))[-1L]), list)
    if (!is.null(package)) {
        if (!is.character(package)) 
            stop("'package' must be a character string or NULL")
        if (FALSE) {
            if (any(package %in% "base")) 
                warning("datasets have been moved from package 'base' to package 'datasets'")
            if (any(package %in% "stats")) 
                warning("datasets have been moved from package 'stats' to package 'datasets'")
            package[package %in% c("base", "stats")] <- "datasets"
        }
    }
    paths <- find.package(package, lib.loc, verbose = verbose)
    if (is.null(lib.loc)) 
        paths <- c(path.package(package, TRUE), if (!length(package)) getwd(), 
            paths)
    paths <- unique(normalizePath(paths[file.exists(paths)]))
    paths <- paths[dir.exists(file.path(paths, "data"))]
    dataExts <- tools:::.make_file_exts("data")
    if (length(names) == 0L) {
        db <- matrix(character(), nrow = 0L, ncol = 4L)
        for (path in paths) {
            entries <- NULL
            packageName <- if (file_test("-f", file.path(path, 
                "DESCRIPTION"))) 
                basename(path)
            else "."
            if (file_test("-f", INDEX <- file.path(path, "Meta", 
                "data.rds"))) {
                entries <- readRDS(INDEX)
            }
            else {
                dataDir <- file.path(path, "data")
                entries <- tools::list_files_with_type(dataDir, 
                  "data")
                if (length(entries)) {
                  entries <- unique(tools::file_path_sans_ext(basename(entries)))
                  entries <- cbind(entries, "")
                }
            }
            if (NROW(entries)) {
                if (is.matrix(entries) && ncol(entries) == 2L) 
                  db <- rbind(db, cbind(packageName, dirname(path), 
                    entries))
                else warning(gettextf("data index for package %s is invalid and will be ignored", 
                  sQuote(packageName)), domain = NA, call. = FALSE)
            }
        }
        colnames(db) <- c("Package", "LibPath", "Item", "Title")
        footer <- if (missing(package)) 
            paste0("Use ", sQuote(paste("data(package =", ".packages(all.available = TRUE))")), 
                "\n", "to list the data sets in all *available* packages.")
        else NULL
        y <- list(title = "Data sets", header = NULL, results = db, 
            footer = footer)
        class(y) <- "packageIQR"
        return(y)
    }
    paths <- file.path(paths, "data")
    for (name in names) {
        found <- FALSE
        for (p in paths) {
            tmp_env <- if (overwrite) 
                envir
            else new.env()
            if (file_test("-f", file.path(p, "Rdata.rds"))) {
                rds <- readRDS(file.path(p, "Rdata.rds"))
                if (name %in% names(rds)) {
                  found <- TRUE
                  if (verbose) 
                    message(sprintf("name=%s:\t found in Rdata.rds", 
                      name), domain = NA)
                  thispkg <- sub(".*/([^/]*)/data$", "\\1", p)
                  thispkg <- sub("_.*$", "", thispkg)
                  thispkg <- paste0("package:", thispkg)
                  objs <- rds[[name]]
                  lazyLoad(file.path(p, "Rdata"), envir = tmp_env, 
                    filter = function(x) x %in% objs)
                  break
                }
                else if (verbose) 
                  message(sprintf("name=%s:\t NOT found in names() of Rdata.rds, i.e.,\n\t%s\n", 
                    name, paste(names(rds), collapse = ",")), 
                    domain = NA)
            }
            if (file_test("-f", file.path(p, "Rdata.zip"))) {
                warning("zipped data found for package ", sQuote(basename(dirname(p))), 
                  ".\nThat is defunct, so please re-install the package.", 
                  domain = NA)
                if (file_test("-f", fp <- file.path(p, "filelist"))) 
                  files <- file.path(p, scan(fp, what = "", quiet = TRUE))
                else {
                  warning(gettextf("file 'filelist' is missing for directory %s", 
                    sQuote(p)), domain = NA)
                  next
                }
            }
            else {
                files <- list.files(p, full.names = TRUE)
            }
            files <- files[grep(name, files, fixed = TRUE)]
            if (length(files) > 1L) {
                o <- match(fileExt(files), dataExts, nomatch = 100L)
                paths0 <- dirname(files)
                paths0 <- factor(paths0, levels = unique(paths0))
                files <- files[order(paths0, o)]
            }
            if (length(files)) {
                for (file in files) {
                  if (verbose) 
                    message("name=", name, ":\t file= ...", .Platform$file.sep, 
                      basename(file), "::\t", appendLF = FALSE, 
                      domain = NA)
                  ext <- fileExt(file)
                  if (basename(file) != paste0(name, ".", ext)) 
                    found <- FALSE
                  else {
                    found <- TRUE
                    zfile <- file
                    zipname <- file.path(dirname(file), "Rdata.zip")
                    if (file.exists(zipname)) {
                      Rdatadir <- tempfile("Rdata")
                      dir.create(Rdatadir, showWarnings = FALSE)
                      topic <- basename(file)
                      rc <- .External(C_unzip, zipname, topic, 
                        Rdatadir, FALSE, TRUE, FALSE, FALSE)
                      if (rc == 0L) 
                        zfile <- file.path(Rdatadir, topic)
                    }
                    if (zfile != file) 
                      on.exit(unlink(zfile))
                    switch(ext, R = , r = {
                      library("utils")
                      sys.source(zfile, chdir = TRUE, envir = tmp_env)
                    }, RData = , rdata = , rda = load(zfile, 
                      envir = tmp_env), TXT = , txt = , tab = , 
                      tab.gz = , tab.bz2 = , tab.xz = , txt.gz = , 
                      txt.bz2 = , txt.xz = assign(name, my_read_table(zfile, 
                        header = TRUE, as.is = FALSE), envir = tmp_env), 
                      CSV = , csv = , csv.gz = , csv.bz2 = , 
                      csv.xz = assign(name, my_read_table(zfile, 
                        header = TRUE, sep = ";", as.is = FALSE), 
                        envir = tmp_env), found <- FALSE)
                  }
                  if (found) 
                    break
                }
                if (verbose) 
                  message(if (!found) 
                    "*NOT* ", "found", domain = NA)
            }
            if (found) 
                break
        }
        if (!found) {
            warning(gettextf("data set %s not found", sQuote(name)), 
                domain = NA)
        }
        else if (!overwrite) {
            for (o in ls(envir = tmp_env, all.names = TRUE)) {
                if (exists(o, envir = envir, inherits = FALSE)) 
                  warning(gettextf("an object named %s already exists and will not be overwritten", 
                    sQuote(o)))
                else assign(o, get(o, envir = tmp_env, inherits = FALSE), 
                  envir = envir)
            }
            rm(tmp_env)
        }
    }
    invisible(names)
}
<bytecode: 0x55787abd4ca0>
<environment: namespace:utils>
> setwd(old_wd)
> unlink(test_dir, recursive = TRUE)
> 
> 
> 
> cleanEx()
> nameEx("load_entrypoint")
> ### * load_entrypoint
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: load_entrypoint
> ### Title: Load project entry points
> ### Aliases: load_entrypoint
> 
> ### ** Examples
> 
> ## Not run: 
> ##D # Create directory to run the example
> ##D old_wd <- getwd()
> ##D test_dir <- file.path(tempdir(), "entrypoint")
> ##D dir.create(test_dir)
> ##D setwd(test_dir)
> ##D # Prepare worcs file and dummy entry point
> ##D worcs:::write_worcsfile(".worcs", entry_point = "test.txt")
> ##D writeLines("Hello world", con = file("test.txt", "w"))
> ##D # Demonstrate load_entrypoint()
> ##D load_entrypoint()
> ##D # Cleaning example directory
> ##D setwd(old_wd)
> ##D unlink(test_dir, recursive = TRUE)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("notify_synthetic")
> ### * notify_synthetic
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: notify_synthetic
> ### Title: Notify the user when synthetic data are being used
> ### Aliases: notify_synthetic
> 
> ### ** Examples
> 
> df <- iris
> class(df) <- c("worcs_data", class(df))
> attr(df, "type") <- "synthetic"
> notify_synthetic(df, msg = "synthetic")
synthetic> 
> 
> 
> cleanEx()
> nameEx("open_data")
> ### * open_data
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: open_data
> ### Title: Use open data in WORCS project
> ### Aliases: open_data
> 
> ### ** Examples
> 
> test_dir <- file.path(tempdir(), "data")
> old_wd <- getwd()
> dir.create(test_dir)
> setwd(test_dir)
> worcs:::write_worcsfile(".worcs")
> df <- iris[1:5, ]
> open_data(df, codebook = NULL)
âœ” Storing original data in 'df.csv' and updating the checksum in '.worcs'.
âœ” Updating '.gitignore'.
âœ” Storing value labels in 'value_labels_df.yml'.
> setwd(old_wd)
> unlink(test_dir, recursive = TRUE)
> 
> 
> 
> cleanEx()
> nameEx("skew_kurtosis")
> ### * skew_kurtosis
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: skew_kurtosis
> ### Title: Calculate skew and kurtosis
> ### Aliases: skew_kurtosis
> 
> ### ** Examples
> 
> skew_kurtosis(datasets::anscombe)
          skew   skew_2se       kurt   kurt_2se
x1  0.00000000  0.0000000 -1.5289256 -0.5975093
x2  0.00000000  0.0000000 -1.5289256 -0.5975093
x3  0.00000000  0.0000000 -1.5289256 -0.5975093
x4  2.46691100  1.8669273  4.5206612  1.7666896
y1 -0.04837355 -0.0366085 -1.1991228 -0.4686212
y2 -0.97869294 -0.7406626 -0.5143191 -0.2009976
y3  1.38012040  1.0444578  1.2400439  0.4846133
y4  1.12077386  0.8481876  0.6287512  0.2457181
> 
> 
> 
> cleanEx()
> nameEx("synthetic")
> ### * synthetic
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: synthetic
> ### Title: Generate synthetic data
> ### Aliases: synthetic
> 
> ### ** Examples
> 
> ## Not run: 
> ##D # Example using the iris dataset and default ranger algorithm
> ##D iris_syn <- synthetic(iris)
> ##D 
> ##D # Example using lm as prediction algorithm (only works for numeric variables)
> ##D # note that, within the model_expression, a new data.frame is created because
> ##D # lm() requires a separate data argument:
> ##D dat <- iris[, 1:4]
> ##D synthetic(dat,
> ##D           model_expression = lm(.outcome ~ .,
> ##D                                 data = data.frame(.outcome = y,
> ##D                                 xsynth)),
> ##D           predict_expression = predict(model, newdata = xsynth))
> ## End(Not run)
> # Example using bootstrapping:
> synthetic(iris,
+           model_expression = NULL,
+           predict_expression = sample(y, size = length(y), replace = TRUE))
  |                                                                              |                                                                      |   0%  |                                                                              |==============                                                        |  20%  |                                                                              |============================                                          |  40%  |                                                                              |==========================================                            |  60%  |                                                                              |========================================================              |  80%  |                                                                              |======================================================================| 100%
    Sepal.Length Sepal.Width Petal.Length Petal.Width    Species
1            5.8         4.4          4.5         0.2     setosa
2            6.4         4.0          5.1         1.3  virginica
3            4.4         3.0          6.0         1.6 versicolor
4            4.3         2.9          5.0         0.2     setosa
5            7.0         2.7          4.8         1.6     setosa
6            5.4         3.9          4.9         1.9     setosa
7            5.4         2.8          4.6         1.5  virginica
8            7.6         2.8          4.0         0.3 versicolor
9            6.1         3.5          3.3         1.0  virginica
10           4.6         2.9          1.2         1.4     setosa
11           6.3         3.0          5.0         1.4  virginica
12           6.0         2.8          4.7         1.3  virginica
13           5.5         3.2          5.1         0.2  virginica
14           6.5         3.7          1.4         2.4     setosa
15           7.2         3.5          1.7         1.5     setosa
16           5.5         2.9          1.4         2.1 versicolor
17           7.6         2.8          1.3         1.4 versicolor
18           7.2         3.1          4.2         2.5  virginica
19           5.6         3.0          5.5         0.2 versicolor
20           5.2         2.3          1.9         1.3     setosa
21           6.0         3.0          4.4         1.8     setosa
22           5.6         3.1          1.3         0.4 versicolor
23           6.1         2.7          5.7         0.1  virginica
24           4.5         3.3          6.1         2.0     setosa
25           6.5         2.6          1.9         0.2 versicolor
26           6.5         3.2          5.2         2.0     setosa
27           5.1         2.6          4.9         1.5     setosa
28           5.0         3.0          1.4         0.3     setosa
29           6.9         2.8          4.7         1.9  virginica
30           6.7         3.2          1.5         0.2 versicolor
31           5.6         3.0          4.5         2.2     setosa
32           6.9         2.8          4.5         0.4  virginica
33           5.1         3.2          1.4         1.3  virginica
34           4.8         2.8          5.6         1.0     setosa
35           7.7         3.0          3.9         0.2  virginica
36           5.6         3.2          4.5         2.0  virginica
37           4.4         2.5          3.3         1.5     setosa
38           4.5         3.4          1.5         1.5     setosa
39           6.3         3.5          5.6         0.2 versicolor
40           5.1         4.0          1.9         1.6     setosa
41           4.3         3.6          6.4         1.5     setosa
42           7.2         3.0          1.3         1.6 versicolor
43           5.1         2.8          6.7         0.2  virginica
44           6.7         3.8          5.6         2.0  virginica
45           5.1         3.1          1.4         1.5  virginica
46           5.8         3.3          5.6         2.4     setosa
47           6.3         2.5          1.5         1.8  virginica
48           5.6         2.8          3.9         1.7  virginica
49           5.6         3.0          1.6         1.9     setosa
50           6.3         3.2          4.6         0.2     setosa
51           7.1         3.1          5.3         2.0     setosa
52           6.4         3.5          4.7         1.2  virginica
53           4.8         3.5          1.4         1.4 versicolor
54           5.1         3.0          4.8         0.1  virginica
55           5.6         3.0          1.5         0.2  virginica
56           4.6         3.4          4.7         0.3 versicolor
57           7.2         2.8          5.1         1.0     setosa
58           6.0         2.3          5.1         1.0 versicolor
59           7.1         2.7          5.4         0.2 versicolor
60           5.2         3.5          5.0         1.5  virginica
61           6.7         3.0          5.0         2.5  virginica
62           5.9         3.1          4.8         2.2     setosa
63           7.3         3.4          6.9         0.2     setosa
64           4.6         2.6          1.6         1.3  virginica
65           5.2         2.6          1.6         0.2 versicolor
66           5.1         3.5          5.8         0.3  virginica
67           6.2         2.9          1.4         2.4 versicolor
68           4.8         3.0          5.3         2.4  virginica
69           5.8         4.1          1.6         0.2 versicolor
70           6.7         3.8          1.3         1.8  virginica
71           6.3         3.0          5.6         1.6  virginica
72           6.7         3.4          6.1         1.5     setosa
73           5.8         3.3          4.5         1.2 versicolor
74           7.7         3.5          1.9         1.5 versicolor
75           5.5         2.9          5.1         1.3 versicolor
76           4.6         4.0          5.3         0.2     setosa
77           4.9         3.0          1.6         1.0 versicolor
78           6.1         2.4          1.5         1.3     setosa
79           7.1         2.9          5.6         0.2  virginica
80           5.2         2.8          1.7         1.9     setosa
81           7.0         3.1          5.7         1.5     setosa
82           5.5         2.8          3.9         0.2 versicolor
83           6.4         3.0          5.8         1.4     setosa
84           6.4         2.9          4.1         2.4 versicolor
85           4.4         3.3          1.6         2.3     setosa
86           5.0         2.6          1.4         2.3     setosa
87           5.8         2.9          5.1         1.3 versicolor
88           5.2         3.0          5.1         1.0  virginica
89           4.6         3.2          4.6         0.6 versicolor
90           4.4         2.8          5.4         1.6  virginica
91           5.1         3.2          3.0         0.2 versicolor
92           5.1         4.0          1.5         0.2 versicolor
93           5.8         3.2          1.6         0.2  virginica
94           5.5         3.5          4.9         1.3 versicolor
95           4.4         2.9          4.8         0.2     setosa
96           5.1         2.7          6.1         1.3 versicolor
97           5.2         2.7          1.2         1.5 versicolor
98           6.7         3.0          5.7         2.1     setosa
99           5.9         2.8          5.3         0.2     setosa
100          5.6         2.7          6.4         0.2  virginica
101          5.2         2.8          4.5         2.4     setosa
102          6.4         3.7          1.4         2.2     setosa
103          5.5         3.1          4.6         1.8  virginica
104          5.0         3.0          4.8         0.2 versicolor
105          6.8         3.1          1.7         0.4 versicolor
106          6.0         2.7          1.3         2.3 versicolor
107          5.9         2.5          4.0         0.3     setosa
108          7.2         2.5          4.7         1.9  virginica
109          5.1         2.7          1.5         1.4 versicolor
110          7.0         2.7          5.1         2.2     setosa
111          5.0         2.8          1.6         1.5  virginica
112          5.3         3.4          1.3         1.5  virginica
113          6.5         2.4          5.3         2.1     setosa
114          5.2         2.5          4.5         1.4 versicolor
115          5.3         2.5          1.5         2.2     setosa
116          5.0         3.0          3.3         1.3     setosa
117          6.1         2.9          4.5         2.1  virginica
118          6.5         3.2          5.1         2.2 versicolor
119          5.1         2.5          4.5         0.2  virginica
120          6.9         3.0          4.5         1.5 versicolor
121          7.0         2.8          5.7         0.1  virginica
122          6.9         3.1          4.4         0.2     setosa
123          6.8         2.7          4.9         2.0 versicolor
124          5.7         2.9          1.6         1.1  virginica
125          7.2         2.8          5.3         0.2     setosa
126          4.6         3.0          1.5         0.2 versicolor
127          5.6         3.1          5.1         1.8  virginica
128          5.0         3.2          1.4         1.3     setosa
129          7.1         3.6          4.1         1.8 versicolor
130          6.5         3.0          4.7         1.8  virginica
131          6.3         3.1          5.1         0.2 versicolor
132          6.8         2.6          4.0         0.2 versicolor
133          6.2         2.5          5.6         0.1  virginica
134          5.7         3.0          1.5         0.4 versicolor
135          5.4         3.0          4.0         1.3  virginica
136          4.8         3.2          4.5         1.5     setosa
137          5.1         3.4          3.8         0.5 versicolor
138          6.3         2.9          1.4         1.5  virginica
139          6.4         3.5          4.0         0.2 versicolor
140          5.7         3.5          5.2         0.1     setosa
141          5.1         3.4          5.1         0.4  virginica
142          4.4         2.6          1.6         1.4  virginica
143          5.0         3.4          4.0         1.2 versicolor
144          6.1         3.2          1.7         0.2     setosa
145          5.6         2.6          5.7         0.2     setosa
146          6.4         3.2          4.8         1.0  virginica
147          6.9         3.3          1.9         1.5  virginica
148          7.2         3.0          1.4         1.3 versicolor
149          4.3         3.4          1.3         1.3  virginica
150          6.4         3.4          1.5         1.6 versicolor
> ## Not run: 
> ##D # Example with missing data, no imputation
> ##D iris_missings <- iris
> ##D for(i in 1:10){
> ##D   iris_missings[sample.int(nrow(iris_missings), 1, replace = TRUE),
> ##D                 sample.int(ncol(iris_missings), 1, replace = TRUE)] <- NA
> ##D }
> ##D iris_miss_syn <- synthetic(iris_missings)
> ##D 
> ##D # Example with missing data, imputation by median/mode substitution
> ##D # First, define a simple function for median/mode substitution:
> ##D imp_fun <- function(x){
> ##D   if(is.data.frame(x)){
> ##D     return(data.frame(sapply(x, imp_fun)))
> ##D   } else {
> ##D     out <- x
> ##D     if(inherits(x, "numeric")){
> ##D       out[is.na(out)] <- median(x[!is.na(out)])
> ##D     } else {
> ##D       out[is.na(out)] <- names(sort(table(out), decreasing = TRUE))[1]
> ##D     }
> ##D     out
> ##D   }
> ##D }
> ##D 
> ##D # Then, call synthetic() with this function as missingness_expression:
> ##D iris_miss_syn <- synthetic(iris_missings,
> ##D                            missingness_expression = imp_fun(data))
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("worcs_badge")
> ### * worcs_badge
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: worcs_badge
> ### Title: Add WORCS badge to README.md
> ### Aliases: worcs_badge
> 
> ### ** Examples
> 
> example_dir <- file.path(tempdir(), "badge")
> dir.create(example_dir)
Warning in dir.create(example_dir) :
  '/tmp/RtmpfS0v1h/badge' already exists
> write("a", file.path(example_dir, ".worcs"))
> worcs_badge(path = example_dir,
+ update_readme = NULL)
> 
> 
> 
> cleanEx()
> nameEx("worcs_project")
> ### * worcs_project
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: worcs_project
> ### Title: Create new WORCS project
> ### Aliases: worcs_project
> 
> ### ** Examples
> 
> the_test <- "worcs_template"
> old_wd <- getwd()
> dir.create(file.path(tempdir(), the_test))
> do.call(git_user, worcs:::get_user())
To set the 'Git' username and email, call 'git_user()' with the argument 'overwrite = TRUE'.
> worcs_project(file.path(tempdir(), the_test, "worcs_project"),
+               manuscript = "github_document",
+               preregistration = "None",
+               add_license = "None",
+               use_renv = FALSE,
+               remote_repo = "https")
âœ” Initializing 'Git' repository.
âœ” Writing '.worcs' file.
âœ” Copying standard files.
âœ” Creating manuscript files.
âœ– Creating first commit (committing README.md).
âœ– Not a valid 'Git' remote repository address: https
âœ– No valid 'GitHub' address provided. You are working with a local 'Git' repository only.
> setwd(old_wd)
> unlink(file.path(tempdir(), the_test))
> 
> 
> 
> ### * <FOOTER>
> ###
> cleanEx()
> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  1.945 0.101 2.449 0.304 0.069 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
